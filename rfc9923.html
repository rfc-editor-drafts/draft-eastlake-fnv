<!DOCTYPE html>
<html lang="en" class="RFC">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>RFC 9923: The FNV Non-Cryptographic Hash Algorithm</title>
<meta content="Landon Curt Noll" name="author">
<meta content="Kiem-Phong Vo" name="author">
<meta content="Donald E. Eastlake 3rd" name="author">
<meta content="Tony Hansen" name="author">
<meta content="
       FNV (Fowler/Noll/Vo) is a fast, non-cryptographic hash algorithm
  with good dispersion that has been widely used and is referenced in a
  number of standards documents. The purpose of this document is to
  make information on FNV and open-source code performing all
  specified sizes of FNV conveniently available to the Internet
  community. 
    " name="description">
<meta content="xml2rfc 3.31.0" name="generator">
<meta content="9923" name="rfc.number">
<!-- Generator version information:
  xml2rfc 3.31.0
    Python 3.14.2
    ConfigArgParse 1.7.1
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.6
    lxml 6.0.2
    platformdirs 4.5.1
    pycountry 24.6.1
    PyYAML 6.0.3
    requests 2.32.5
    wcwidth 0.2.14
-->
<link href="1772042968466.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necessary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://static.ietf.org/fonts/noto-sans/import.css'); /* Sans-serif */
@import url('https://static.ietf.org/fonts/noto-serif/import.css'); /* Serif (print) */
@import url('https://static.ietf.org/fonts/roboto-mono/import.css'); /* Monospace */

:root {
  --font-sans: 'Noto Sans', Arial, Helvetica, sans-serif;
  --font-serif: 'Noto Serif', 'Times', 'Times New Roman', serif;
  --font-mono: 'Roboto Mono', Courier, 'Courier New', monospace;
}

@viewport {
  zoom: 1.0;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: var(--font-sans);
  line-height: 1.6;
  scroll-behavior: smooth;
  overflow-wrap: break-word;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
@media print {
  svg {
    max-height: 850px;
    max-width: 660px;
  }
}
svg[font-family~="serif" i], svg [font-family~="serif" i] {
  font-family: var(--font-serif);
}
svg[font-family~="sans-serif" i], svg [font-family~="sans-serif" i] {
  font-family: var(--font-sans);
}
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  display: table;
  border: none;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.ulBare, li.ulBare {
  margin-left: 0em !important;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre {
  background-color: #f9f9f9;
  font-family: var(--font-mono);
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
blockquote > *:last-child {
  margin-bottom: 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}
.xref {
  overflow-wrap: normal;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
/* Fix PDF info block run off issue */
@media print {
  #identifiers dd {
    max-width: 100%;
  }
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.refSubseries {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: var(--font-sans);
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  .breakable pre {
    break-inside: auto;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The following is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
.sourcecode pre,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .artwork > pre,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: upper-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background slightly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr {
  break-inside: avoid;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: auto;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-before: auto;
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
span.break, dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}
/* Text in compact lists should not get extra bottom margin space,
   since that would makes the list not compact */
ul.compact p, .ulCompact p,
ol.compact p, .olCompact p {
 margin: 0;
}
/* But the list as a whole needs the extra space at the end */
section ul.compact,
section .ulCompact,
section ol.compact,
section .olCompact {
  margin-bottom: 1em;                    /* same as p not within ul.compact etc. */
}
/* The tt and code background above interferes with for instance table cell
   backgrounds.  Changed to something a bit more selective. */
tt, code {
  background-color: transparent;
}
p tt, p code, li tt, li code, dt tt, dt code {
  background-color: #f8f8f8;
}
/* Tweak the pre margin -- 0px doesn't come out well */
pre {
   margin-top: 0.5px;
}
/* Tweak the compact list text */
ul.compact, .ulCompact,
ol.compact, .olCompact,
dl.compact, .dlCompact {
  line-height: normal;
}
/* Don't add top margin for nested lists */
li > ul, li > ol, li > dl,
dd > ul, dd > ol, dd > dl,
dl > dd > dl {
  margin-top: initial;
}
/* Elements that should not be rendered on the same line as a <dt> */
/* This should match the element list in writer.text.TextWriter.render_dl() */
dd > div.artwork:first-child,
dd > aside:first-child,
dd > blockquote:first-child,
dd > figure:first-child,
dd > ol:first-child,
dd > div.sourcecode:first-child,
dd > table:first-child,
dd > ul:first-child {
  clear: left;
}
/* fix for weird browser behaviour when <dd/> is empty */
dt+dd:empty::before{
  content: "\00a0";
}
/* Make paragraph spacing inside <li> smaller than in body text, to fit better within the list */
li > p {
  margin-bottom: 0.5em
}
/* Don't let p margin spill out from inside list items */
li > p:last-of-type:only-child {
  margin-bottom: 0;
}
</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
<link href="https://datatracker.ietf.org/doc/draft-eastlake-fnv-35" rel="prev">
  <link href="https://dx.doi.org/10.17487/rfc9923" rel="alternate">
  <link href="urn:issn:2070-1721" rel="alternate">
  </head>
<body class="xml2rfc">
<script src="https://www.rfc-editor.org/js/metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">RFC 9923</td>
<td class="center">FNV</td>
<td class="right">February 2026</td>
</tr></thead>
<tfoot><tr>
<td class="left">Noll, et al.</td>
<td class="center">Informational</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-stream">Stream:</dt>
<dd class="stream">Independent Submission</dd>
<dt class="label-rfc">RFC:</dt>
<dd class="rfc"><a href="https://www.rfc-editor.org/rfc/rfc9923" class="eref">9923</a></dd>
<dt class="label-category">Category:</dt>
<dd class="category">Informational</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2026-02" class="published">February 2026</time>
    </dd>
<dt class="label-issn">ISSN:</dt>
<dd class="issn">2070-1721</dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">L. Noll</div>
</div>
<div class="author">
      <div class="author-name">K. Vo</div>
<div class="org">Google</div>
</div>
<div class="author">
      <div class="author-name">D. Eastlake 3rd</div>
<div class="org">Independent</div>
</div>
<div class="author">
      <div class="author-name">T. Hansen</div>
<div class="org">AT&amp;T</div>
</div>
</dd>
</dl>
</div>
<h1 id="rfcnum">RFC 9923</h1>
<h1 id="title">The FNV Non-Cryptographic Hash Algorithm</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">FNV (Fowler/Noll/Vo) is a fast, non-cryptographic hash algorithm
  with good dispersion that has been widely used and is referenced in a
  number of standards documents. The purpose of this document is to
  make information on FNV and open-source code performing all
  specified sizes of FNV conveniently available to the Internet
  community.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
            This document is not an Internet Standards Track specification; it is
            published for informational purposes.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
            This is a contribution to the RFC Series, independently of any
            other RFC stream.  The RFC Editor has chosen to publish this
            document at its discretion and makes no statement about its value
            for implementation or deployment.  Documents approved for
            publication by the RFC Editor are not candidates for any level of
            Internet Standard; see Section 2 of RFC 7841.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
            Information about the current status of this document, any
            errata, and how to provide feedback on it may be obtained at
            <span><a href="https://www.rfc-editor.org/info/rfc9923">https://www.rfc-editor.org/info/rfc9923</a></span>.<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2026 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-conventions-used-in-this-do" class="internal xref">Conventions Used in This Document</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-applicability-of-non-crypto" class="internal xref">Applicability of Non-Cryptographic Hashes and FNV</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="auto internal xref">1.3</a>.  <a href="#name-fnv-hash-uses" class="internal xref">FNV Hash Uses</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.4">
                <p id="section-toc.1-1.1.2.4.1"><a href="#section-1.4" class="auto internal xref">1.4</a>.  <a href="#name-why-is-fnv-non-cryptographi" class="internal xref">Why Is FNV Non-Cryptographic?</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-fnv-basics" class="internal xref">FNV Basics</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="auto internal xref">2.1</a>.  <a href="#name-fnv-primes" class="internal xref">FNV Primes</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="auto internal xref">2.2</a>.  <a href="#name-fnv-offset_basis" class="internal xref">FNV offset_basis</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="auto internal xref">2.3</a>.  <a href="#name-fnv-endianism" class="internal xref">FNV Endianism</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-other-hash-sizes-and-xor-fo" class="internal xref">Other Hash Sizes and XOR Folding</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-hashing-multiple-values-tog" class="internal xref">Hashing Multiple Values Together</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-fnv-constants" class="internal xref">FNV Constants</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-inducing-collisions" class="internal xref">Inducing Collisions</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-historical-notes" class="internal xref">Historical Notes</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-the-source-code" class="internal xref">The Source Code</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="auto internal xref">8.1</a>.  <a href="#name-source-code-details" class="internal xref">Source Code Details</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1.2.1">
                    <p id="section-toc.1-1.8.2.1.2.1.1"><a href="#section-8.1.1" class="auto internal xref">8.1.1</a>.  <a href="#name-fnv-functions-available" class="internal xref">FNV Functions Available</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1.2.2">
                    <p id="section-toc.1-1.8.2.1.2.2.1"><a href="#section-8.1.2" class="auto internal xref">8.1.2</a>.  <a href="#name-source-files-and-64-bit-sup" class="internal xref">Source Files and 64-Bit Support</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1.2.3">
                    <p id="section-toc.1-1.8.2.1.2.3.1"><a href="#section-8.1.3" class="auto internal xref">8.1.3</a>.  <a href="#name-command-line-interface" class="internal xref">Command Line Interface</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="auto internal xref">8.2</a>.  <a href="#name-fnv-1a-c-code" class="internal xref">FNV-1a C Code</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.1">
                    <p id="section-toc.1-1.8.2.2.2.1.1"><a href="#section-8.2.1" class="auto internal xref">8.2.1</a>.  <a href="#name-fnv32-code" class="internal xref">FNV32 Code</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.2">
                    <p id="section-toc.1-1.8.2.2.2.2.1"><a href="#section-8.2.2" class="auto internal xref">8.2.2</a>.  <a href="#name-fnv64-code" class="internal xref">FNV64 Code</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.3">
                    <p id="section-toc.1-1.8.2.2.2.3.1"><a href="#section-8.2.3" class="auto internal xref">8.2.3</a>.  <a href="#name-fnv128-code" class="internal xref">FNV128 Code</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.4">
                    <p id="section-toc.1-1.8.2.2.2.4.1"><a href="#section-8.2.4" class="auto internal xref">8.2.4</a>.  <a href="#name-fnv256-code" class="internal xref">FNV256 Code</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.5">
                    <p id="section-toc.1-1.8.2.2.2.5.1"><a href="#section-8.2.5" class="auto internal xref">8.2.5</a>.  <a href="#name-fnv512-code" class="internal xref">FNV512 Code</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.6">
                    <p id="section-toc.1-1.8.2.2.2.6.1"><a href="#section-8.2.6" class="auto internal xref">8.2.6</a>.  <a href="#name-fnv1024-code" class="internal xref">FNV1024 Code</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="auto internal xref">8.3</a>.  <a href="#name-fnv-test-code" class="internal xref">FNV Test Code</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.4">
                <p id="section-toc.1-1.8.2.4.1"><a href="#section-8.4" class="auto internal xref">8.4</a>.  <a href="#name-makefile" class="internal xref">Makefile</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="auto internal xref">10.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="auto internal xref">10.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-work-comparison-with-sha-1-" class="internal xref">Work Comparison with SHA-1 and SHA-256</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-previous-ietf-fnv-code" class="internal xref">Previous IETF FNV Code</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-C" class="auto internal xref"></a><a href="#name-acknowledgements" class="internal xref">Acknowledgements</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-D" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">FNV (Fowler/Noll/Vo) hashes are designed to be fast and have a
  small code footprint.  Their good dispersion makes them particularly
  well suited for hashing nearly identical strings, including URLs,
  hostnames, filenames, text, and IP and Media Access Control (MAC) addresses. Their speed
  allows one to quickly hash lots of data.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The purpose of this document is to make information on FNV and
  open-source code performing all specified sizes of FNV conveniently
  available to the Internet community. This work is not an Internet
  Standard and does not have the consensus of the IETF community.<a href="#section-1-2" class="pilcrow">¶</a></p>
<section id="section-1.1">
        <h3 id="name-conventions-used-in-this-do">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-conventions-used-in-this-do" class="section-name selfRef">Conventions Used in This Document</a>
        </h3>
<p id="section-1.1-1">The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>",
       "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>",
       "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>",
       "<span class="bcp14">SHOULD NOT</span>",
       "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
       "<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document
       are to be interpreted as described in BCP 14
       <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only
       when, they appear in all capitals, as shown here.<a href="#section-1.1-1" class="pilcrow">¶</a></p>
</section>
<div id="applicability">
<section id="section-1.2">
        <h3 id="name-applicability-of-non-crypto">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-applicability-of-non-crypto" class="section-name selfRef">Applicability of Non-Cryptographic Hashes and FNV</a>
        </h3>
<p id="section-1.2-1">While a general theory of hash function strength and utility is
  beyond the scope of this document, typical attacks on hash functions
  involve one of the following:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-1.2-2">
          <dt id="section-1.2-2.1">Collision:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.2">Finding two data inputs that yield the same
    hash output.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.3">First Pre-Image:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.4">Given a hash output, finding a data
    input that hashes to that output.<a href="#section-1.2-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.5">Second Pre-Image:</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.6">Given a first data input, finding a
    second input that produces the same hash output as the first.<a href="#section-1.2-2.6" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-1.2-3">For a hash function producing N bits, there necessarily will be
  collisions among the hashes of more than 2<sup>N</sup> distinct inputs. And
  if the hash function can produce hashes covering all 2<sup>N</sup> possible
  outputs, then there will exist first and second pre-images. FNV is
  <span class="bcp14">NOT RECOMMENDED</span> for any application that requires that it be
  computationally infeasible for one of the above types of
  attacks to succeed.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<p id="section-1.2-4">FNV hashes are generally not applicable for use when faced with
  an active adversary in a security scheme where the modest effort
  required to compute FNV hashes (see <a href="#Effort" class="auto internal xref">Appendix A</a>) and
  their other non-cryptographic characteristics (see <a href="#noncrypto" class="auto internal xref">Section 1.4</a>) would make the scheme ineffective against the
  threat model being considered. It is sometimes hard to determine
  whether or not there are attack vectors via a hash.<a href="#section-1.2-4" class="pilcrow">¶</a></p>
<p id="section-1.2-5">For a discussion of adversarial inducement of collisions, see
  <a href="#bang" class="auto internal xref">Section 6.1</a>.<a href="#section-1.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="Uses">
<section id="section-1.3">
        <h3 id="name-fnv-hash-uses">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-fnv-hash-uses" class="section-name selfRef">FNV Hash Uses</a>
        </h3>
<p id="section-1.3-1">The FNV hash has been widely used. Examples include the
    following:<a href="#section-1.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.3-2.1">NFS implementations (e.g., FreeBSD 4.3 <span>[<a href="#FreeBSD" class="cite xref">FreeBSD</a>]</span>, IRIX, Linux (NFS v4)),<a href="#section-1.3-2.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.2">text-based referenced resources for video games on the PS2,
      Gamecube, and XBOX,<a href="#section-1.3-2.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.3">to improve the fragment cache <span>[<a href="#FragCache" class="cite xref">FragCache</a>]</span> at
      X (formerly Twitter),<a href="#section-1.3-2.3" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.4">the flatassembler open-source x86 assembler - user-defined
      symbol hashtree <span>[<a href="#flatassembler" class="cite xref">flatassembler</a>]</span>,<a href="#section-1.3-2.4" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.5">used in the speed-sensitive guts of <span>[<a href="#twistylists" class="cite xref">twistylists</a>]</span>, an open-source structured namespace
      manager,<a href="#section-1.3-2.5" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.6">database indexing hashes,<a href="#section-1.3-2.6" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.7">PowerBASIC inline assembly routine <span>[<a href="#BASIC" class="cite xref">BASIC</a>]</span>,<a href="#section-1.3-2.7" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.8">major web search / indexing engines,<a href="#section-1.3-2.8" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.9">the "calc" C-style calculator <span>[<a href="#calc" class="cite xref">calc</a>]</span>,<a href="#section-1.3-2.9" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.10">netnews history file Message-ID lookup functions,<a href="#section-1.3-2.10" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.11">
            <span>[<a href="#FRET" class="cite xref">FRET</a>]</span> - a tool to identify file data
      structures / help understand file formats,<a href="#section-1.3-2.11" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.12">anti-spam filters,<a href="#section-1.3-2.12" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.13">used in an implementation of libketama <span>[<a href="#libketama" class="cite xref">libketama</a>]</span> for use in items
      such as <span>[<a href="#memcache" class="cite xref">memcache</a>]</span>,<a href="#section-1.3-2.13" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.14">a spellchecker programmed in Ada 95,<a href="#section-1.3-2.14" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.15">used in the BSD Integrated Development Environments (IDE) project <span>[<a href="#fasmlab" class="cite xref">fasmlab</a>]</span>,<a href="#section-1.3-2.15" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.16">non-cryptographic file fingerprints,<a href="#section-1.3-2.16" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.17">used in the deliantra game server for its shared
      string implementation <span>[<a href="#deliantra" class="cite xref">deliantra</a>]</span>,<a href="#section-1.3-2.17" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.18">computing Unique IDs in DASM (DTN (Delay Tolerant
      Networking) Applications for Symbian Mobile-phones),<a href="#section-1.3-2.18" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.19">Microsoft's hash_map implementation for VC++ 2005,<a href="#section-1.3-2.19" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.20">the realpath cache in PHP 5.x
      (php-5.2.3/TSRM/tsrm_virtual_cwd.c),<a href="#section-1.3-2.20" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.21">DNS (Domain Name System) servers,<a href="#section-1.3-2.21" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.22">used to improve <span>[<a href="#Leprechaun" class="cite xref">Leprechaun</a>]</span>, an extremely
      fast wordlist creator,<a href="#section-1.3-2.22" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.23">the Smash utility <span>[<a href="#Smash" class="cite xref">Smash</a>]</span> for rapidly finding duplicate files,<a href="#section-1.3-2.23" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.24">Golf language hash tables <span>[<a href="#RimStone" class="cite xref">RimStone</a>]</span>,<a href="#section-1.3-2.24" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.25">the libsir logging library <span>[<a href="#libsir" class="cite xref">libsir</a>]</span>,<a href="#section-1.3-2.25" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-1.3-2.26">a standard library for modern Fortran <span>[<a href="#Fortran" class="cite xref">Fortran</a>]</span>,<a href="#section-1.3-2.26" class="pilcrow">¶</a>
</li>
        </ul>
<p id="section-1.3-3">and many other uses.  It is also referenced in the following standards documents: <span>[<a href="#RFC7357" class="cite xref">RFC7357</a>]</span>, <span>[<a href="#RFC7873" class="cite xref">RFC7873</a>]</span>, and <span>[<a href="#IEEE8021Q-2022" class="cite xref">IEEE8021Q-2022</a>]</span>.<a href="#section-1.3-3" class="pilcrow">¶</a></p>
<p id="section-1.3-4">A study has recommended FNV in connection with the IPv6 flow
  label value <span>[<a href="#IPv6flow" class="cite xref">IPv6flow</a>]</span>. Additionally, there was a
  proposal to use FNV for Bidirectional Forwarding Detection (BFD) sequence number generation <span>[<a href="#BFDseq" class="cite xref">BFDseq</a>]</span>. <span>[<a href="#NCHF" class="cite xref">NCHF</a>]</span> discusses criteria for evaluating non-cryptographic hash
functions.<a href="#section-1.3-4" class="pilcrow">¶</a></p>
<p id="section-1.3-5">If you use an FNV function in an application, you are kindly requested to send a note via the process outlined at <span>&lt;<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html#address">http://www.isthe.com/chongo/tech/comp/fnv/index.html#address</a>&gt;</span>.<a href="#section-1.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="noncrypto">
<section id="section-1.4">
        <h3 id="name-why-is-fnv-non-cryptographi">
<a href="#section-1.4" class="section-number selfRef">1.4. </a><a href="#name-why-is-fnv-non-cryptographi" class="section-name selfRef">Why Is FNV Non-Cryptographic?</a>
        </h3>
<p id="section-1.4-1">A full discussion of cryptographic hash requirements and strength
is beyond the scope of this document. However, here are three
characteristics of FNV that would generally be considered to make it
non-cryptographic:<a href="#section-1.4-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1.4-2">
  <li id="section-1.4-2.1">Sticky State - A cryptographic hash should not have a state in
  which it can stick for a plausible input pattern. But in the very
  unlikely event that the FNV hash variable accidentally becomes zero
  and the input is a sequence of zero bytes, the hash variable will
  remain at zero until there is a non-zero input byte and the final
  hash value will be unaffected by the length of that sequence of zero
  input bytes. For the common case of fixed-length input, this would
  usually not be significant because the number of non-zero bytes
  would vary inversely with the number of zero bytes and for some
  types of input, runs of zeros do not occur. Furthermore, the use of
  a different offset_basis or the inclusion of even a little
  unpredictable input may be sufficient, under some circumstances, to
  stop an adversary from inducing a zero hash variable (see <a href="#bang" class="auto internal xref">Section 6.1</a>).<a href="#section-1.4-2.1" class="pilcrow">¶</a>
</li>
          <li id="section-1.4-2.2">Diffusion - Every output bit of a cryptographic hash should be
  an equally complex function of every input bit. But it is easy to
  see that the least significant bit of a direct FNV hash is the XOR
  of the least significant bits of every input byte and does not
  depend on any other input bits. While more complex, the second
  through seventh least significant bits of an FNV hash have a similar
  weakness; only the top bit of the bottom byte of output, and higher-order bits, depend on all input bits. If these properties are
  considered a problem, they can be easily fixed by XOR folding (see
  <a href="#fold" class="auto internal xref">Section 3</a>).<a href="#section-1.4-2.2" class="pilcrow">¶</a>
</li>
          <li id="section-1.4-2.3">Work Factor - Depending on intended use, it is frequently
  desirable that a hash function should be computationally expensive
  for general-purpose and graphics processors, since these may be
  profusely available through elastic cloud services or botnets.  This
  is applied to slow down testing of possible inputs if the output is known or
  the like. But FNV is designed to be inexpensive on a general-purpose
  processor (see <a href="#Effort" class="auto internal xref">Appendix A</a>).<a href="#section-1.4-2.3" class="pilcrow">¶</a>
</li>
        </ol>
<p id="section-1.4-3">Nevertheless, none of the above have proven to be a problem in
actual practice for the many non-cryptographic applications of FNV
(see <a href="#Uses" class="auto internal xref">Section 1.3</a>).<a href="#section-1.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
<section id="section-2">
      <h2 id="name-fnv-basics">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-fnv-basics" class="section-name selfRef">FNV Basics</a>
      </h2>
<p id="section-2-1">This document focuses on the FNV-1a function, whose pseudocode is
as follows:<a href="#section-2-1" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-2-2">
<pre>
  hash = offset_basis
  for each octet_of_data to be hashed
      hash = hash XOR octet_of_data
      hash = hash * FNV_Prime mod 2**HashSize
  return hash
</pre><a href="#section-2-2" class="pilcrow">¶</a>
</div>
<p id="section-2-3">In the pseudocode above, hash is a power-of-2 number of bits
(HashSize is 32, 64, 128, 256, 512, or 1024), and offset_basis and
FNV_Prime depend on the size of hash.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">The FNV-1 algorithm is the same, including the values of
offset_basis and FNV_Prime, except that the order of the two lines
with the "XOR" and multiply operations is reversed. Operational
experience indicates better hash dispersion for small amounts of data
with FNV-1a. FNV-0 is the same as FNV-1 but with offset_basis set to
zero. FNV-1a is suggested for general use.<a href="#section-2-4" class="pilcrow">¶</a></p>
<section id="section-2.1">
        <h3 id="name-fnv-primes">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-fnv-primes" class="section-name selfRef">FNV Primes</a>
        </h3>
<p id="section-2.1-1">The theory behind FNV_Primes is beyond the scope of this document,
but the basic property to look for is how an FNV_Prime would impact
dispersion. Now, consider any n-bit FNV hash where n &gt;= 32 and is also
a power of 2 -- in particular, n = 2<sup>s</sup>. For each such n-bit FNV hash, an
FNV_Prime p is defined as follows:<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2.1-2.1">
            <p id="section-2.1-2.1.1">When s is an integer and 4 &lt; s &lt; 11,
  FNV_Prime is the smallest prime p of the form:<a href="#section-2.1-2.1.1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.1-2.1.2">
<pre>                  256**int((5 + 2**s)/12) + 2**8 + b
</pre><a href="#section-2.1-2.1.2" class="pilcrow">¶</a>
</div>
</li>
          <li class="normal" id="section-2.1-2.2">
            <p id="section-2.1-2.2.1">where b is an integer such that:<a href="#section-2.1-2.2.1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.1-2.2.2">
<pre>                               0 &lt; b &lt; 2**8
</pre><a href="#section-2.1-2.2.2" class="pilcrow">¶</a>
</div>
</li>
          <li class="normal" id="section-2.1-2.3">
            <p id="section-2.1-2.3.1">The number of one bits in b is four or five<a href="#section-2.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-2.1-2.4">
            <p id="section-2.1-2.4.1">and where<a href="#section-2.1-2.4.1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.1-2.4.2">
<pre>      ( p mod (2**40 - 2**24 - 1) ) &gt; ( 2**24 + 2**8 + 2**7 )
</pre><a href="#section-2.1-2.4.2" class="pilcrow">¶</a>
</div>
</li>
        </ul>
<p id="section-2.1-3">Experimentally, FNV_Primes matching the above constraints tend to
have better dispersion properties. They improve the polynomial
feedback characteristic when an FNV_Prime multiplies an intermediate
hash value. As such, the hash values produced are more scattered
throughout the n-bit hash space.<a href="#section-2.1-3" class="pilcrow">¶</a></p>
<p id="section-2.1-4">The case where s &lt; 5 is not considered due to the resulting low
hash quality. Such small hashes can, if desired, be derived from a
32-bit FNV hash by XOR folding (see <a href="#fold" class="auto internal xref">Section 3</a>). The case
where s &gt; 10 is not considered because of the doubtful utility of such
large FNV hashes and because the criteria for such large FNV_Primes would
be more complex, due to the sparsity of such large primes, and would
needlessly clutter the criteria given above.<a href="#section-2.1-4" class="pilcrow">¶</a></p>
<p id="section-2.1-5">Per the above constraints, an FNV_Prime should have only six or seven
one bits in it: one relatively high-order one bit, the 2<sup>9</sup> bit, and four
or five one bits in the low-order byte. Therefore, some compilers may
seek to improve the performance of a multiplication with an FNV_Prime
by replacing the multiplication with shifts and adds.  However, the
performance of this substitution is highly hardware dependent and
should be done with care. The selection of FNV_Primes prioritizes the
quality of the resulting hash function, not compiler optimization
considerations.<a href="#section-2.1-5" class="pilcrow">¶</a></p>
</section>
<div id="constoffb">
<section id="section-2.2">
        <h3 id="name-fnv-offset_basis">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-fnv-offset_basis" class="section-name selfRef">FNV offset_basis</a>
        </h3>
<p id="section-2.2-1">The offset_basis values for the n-bit FNV-1a algorithms are
computed by applying the n-bit FNV-0 algorithm to the following
32-octet ASCII <span>[<a href="#RFC0020" class="cite xref">RFC0020</a>]</span> character string:<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.2-2">
<pre>                     chongo &lt;Landon Curt Noll&gt; /\../\
</pre><a href="#section-2.2-2" class="pilcrow">¶</a>
</div>
<p id="section-2.2-3">or, in C notation <span>[<a href="#C" class="cite xref">C</a>]</span>, the following string:<a href="#section-2.2-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-2.2-4">
<pre>                    "chongo &lt;Landon Curt Noll&gt; /\\../\\"
</pre><a href="#section-2.2-4" class="pilcrow">¶</a>
</div>
<p id="section-2.2-5">In the general case, almost any offset_basis would serve as long as
it is non-zero. However, FNV hashes calculated with different
offset_basis values will not interoperate. The choice of a
non-standard offset_basis may be beneficial in some limited
circumstances to defend against attacks that try to induce hash
collisions as discussed in <a href="#bang" class="auto internal xref">Section 6.1</a>. Any entity that can
observe the FNV hash output and can cause the null string (the string
of length zero) to be hashed will thereby be able to directly observe
the offset_basis which will be the hash output.<a href="#section-2.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="endian">
<section id="section-2.3">
        <h3 id="name-fnv-endianism">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-fnv-endianism" class="section-name selfRef">FNV Endianism</a>
        </h3>
<p id="section-2.3-1">For persistent storage or interoperability between different
hardware platforms, an FNV hash shall be represented in the
little-endian format <span>[<a href="#IEN137" class="cite xref">IEN137</a>]</span>. That is, the FNV hash will be
stored in an array hash[N] with N bytes such that its integer value
can be retrieved as follows:<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<div class="lang-c sourcecode" id="section-2.3-2">
<pre>
  unsigned char   hash[N];
  for ( i = N-1, value = 0; i &gt;= 0; --i )
      value = ( value &lt;&lt; 8 ) + hash[i];
</pre><a href="#section-2.3-2" class="pilcrow">¶</a>
</div>
<p id="section-2.3-3">However, when FNV hashes are used in a single process or a group
of processes sharing memory on processors with compatible endianness,
the natural endianness of those processors can be used, as long as it
is used consistently, regardless of its type -- little, big, or some
other exotic form.<a href="#section-2.3-3" class="pilcrow">¶</a></p>
<p id="section-2.3-4">The code provided in <a href="#SourceCode" class="auto internal xref">Section 8</a> has FNV hash functions that return a
little-endian byte vector for all lengths. Because they are more
efficient, the code also provides functions that return FNV hashes as
32-bit integers or, where supported, 64-bit integers, for those sizes
of FNV hash. Such integers are compatible with the same-size byte
vectors on little-endian computers, but the use of the functions returning
integers on big-endian or other non-little-endian machines will be
byte-reversed or otherwise incompatible with the byte vector return
values.<a href="#section-2.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
<div id="fold">
<section id="section-3">
      <h2 id="name-other-hash-sizes-and-xor-fo">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-other-hash-sizes-and-xor-fo" class="section-name selfRef">Other Hash Sizes and XOR Folding</a>
      </h2>
<p id="section-3-1">Many hash uses require a hash that is not one of the FNV sizes for
which constants are provided in <a href="#const" class="auto internal xref">Section 5</a>.  If a larger
hash size is needed, please contact the authors of this document.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">For scenarios where a fixed-size binary field of k bits is desired
with k &lt; 1024 but not among the constants provided in <a href="#const" class="auto internal xref">Section 5</a>,
the recommended approach involves using the smallest FNV hash of size
S where S &gt; k and employing XOR folding, as shown below. The final
bit-masking operation is logically unnecessary if the size of the
variable k-bit-hash is exactly k bits.<a href="#section-3-2" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-3-3">
<pre>
  temp = FNV_S ( data-to-be-hashed )
  k-bit-hash = ( temp XOR temp&gt;&gt;k ) bitwise-and ( 2**k - 1 )
</pre><a href="#section-3-3" class="pilcrow">¶</a>
</div>
<p id="section-3-4">A somewhat stronger hash may be obtained for exact FNV sizes by
calculating an FNV twice as long as the desired output ( S = 2*k ) and
performing such XOR data folding using a k equal to the size of the
desired output. However, if a much stronger hash is desired,
cryptographic algorithms, such as those specified in <span>[<a href="#FIPS202" class="cite xref">FIPS202</a>]</span> or
<span>[<a href="#RFC6234" class="cite xref">RFC6234</a>]</span>, should be used.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">If it is desired to obtain a hash result that is a value between 0
and max, where max+1 is not a power of 2, simply choose an FNV
hash size S such that 2<sup>S</sup> &gt; max. Then, calculate the following:<a href="#section-3-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-3-6">
<pre>                          FNV_S mod ( max+1 )
</pre><a href="#section-3-6" class="pilcrow">¶</a>
</div>
<p id="section-3-7">The resulting remainder will be in the range desired but will
suffer from a bias against large values, with the bias being larger if
2<sup>S</sup> is only slightly larger than max. If this bias is acceptable, no
further processing is needed. If this bias is unacceptable, it can be
avoided by retrying for certain high values of hash, as follows,
before applying the mod operation above:<a href="#section-3-7" class="pilcrow">¶</a></p>
<div class="lang-pseudocode sourcecode" id="section-3-8">
<pre>
  X = ( int( ( 2**S - 1 ) / ( max+1 ) ) ) * ( max+1 )
  while ( hash &gt;= X )
      hash = ( hash * FNV_Prime ) + offset_basis
</pre><a href="#section-3-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec-4">
<section id="section-4">
      <h2 id="name-hashing-multiple-values-tog">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-hashing-multiple-values-tog" class="section-name selfRef">Hashing Multiple Values Together</a>
      </h2>
<p id="section-4-1">Sometimes, there are multiple different component values, say three
strings X, Y, and Z, where a hash over all of them is desired.  The
simplest thing to do is to concatenate them in a fixed order and
compute the hash of that concatenation, as in<a href="#section-4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4-2">
<pre>                          hash ( X | Y | Z )
</pre><a href="#section-4-2" class="pilcrow">¶</a>
</div>
<p id="section-4-3">where the vertical bar character ("|") represents string
concatenation. If the components being combined are of variable
length, some information is lost by simple concatenation. For example,
X = "12" and Y = "345" would not be distinguished from X = "123" and Y
= "45". To preserve that information, each component should be
preceded by an encoding of its length or should end with some sequence that
cannot occur within the component, or some similar technique should be
used.<a href="#section-4-3" class="pilcrow">¶</a></p>
<p id="section-4-4">For FNV, the same hash results if 1) X, Y, and Z are actually
concatenated and the FNV hash is applied to the resulting string or
2) FNV is calculated on an initial substring and the result is used as the
offset_basis when calculating the FNV hash of the remainder of the
string.  This can be done several times. Assuming that FNVoffset_basis ( v,
w ) is the FNV of w using v as the offset_basis, then in the example
above, fnvx = FNV ( X ) could be calculated and then fnvxy =
FNVoffset_basis ( fnvx, Y ), and finally fnvxyz = FNVoffset_basis (
fnvxy, Z ). The resulting fnvxyz would be the same as FNV ( X | Y | Z ).<a href="#section-4-4" class="pilcrow">¶</a></p>
<p id="section-4-5">This means that if you have the value of FNV ( X ) and you want to
calculate FNV ( X | Y ), you do not need to find X. You can simply
calculate FNVoffset_basis ( FNV ( X ), Y ) and thereby get FNV ( X | Y ).<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">Sometimes, such a hash needs to be repeatedly calculated; the
component values vary, but some vary more frequently than others.  For
example, assume that some sort of computer network traffic flow ID, such as
the IPv6 Flow Label <span>[<a href="#RFC6437" class="cite xref">RFC6437</a>]</span>, is to be calculated for
network packets based on the source and destination IPv6 addresses and
the Traffic Class <span>[<a href="#RFC8200" class="cite xref">RFC8200</a>]</span>. If the Flow Label is
calculated in the originating host, the source IPv6 address would
likely always be the same or would perhaps assume one of a very small number
of values. By placing this quasi-constant IPv6 source address first in
the string being FNV-hashed, FNV ( IPv6source ) could be calculated
and used as the offset_basis for calculating the FNV of the IPv6
destination address and Traffic Class for each packet. As a result,
the per-packet hash would be over 17 bytes rather than over 33 bytes,
saving computational resources. The source code in this document
includes functions facilitating the use of a non-standard
offset_basis.<a href="#section-4-6" class="pilcrow">¶</a></p>
<p id="section-4-7">An alternative method of hashing multiple values is to concatenate
the hashes of those values and then hash the concatenation -- that is,
compute something like<a href="#section-4-7" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4-8">
<pre>                 hash ( hash (X) | hash (Y) | hash (Z) )
</pre><a href="#section-4-8" class="pilcrow">¶</a>
</div>
<p id="section-4-9">This will involve more computation than simply computing the hash
of the concatenation of the values and thus, unless parallel
computational resources are available, greater latency; however, if
parallel computational resources are available and the values being
hashed together are long enough to overcome any initial/final hash
function overhead, which is very small for FNV, latency can be reduced
by hashing the concatenation of the hashes of the values.<a href="#section-4-9" class="pilcrow">¶</a></p>
<p id="section-4-10">For another example of a similar technique, assume a desire to use
FNV-N to hash a byte string of length L. Let B = N/8, the number of
bytes of FNV-N output. If that string is divided into k successive
substrings of equal length and assuming, for simplicity, that L is an
integer multiple of k, hashing the substrings and then hashing the
concatenation of their hashes will hash a total of L + k*B bytes,
clearly more than the initial string size L. However, if sufficient
parallel computational resources are available to hash all the
substrings simultaneously, the elapsed time can be changed
approximately from on the order of L to on the order of L/k + k*B. For
sufficiently large L, this parallelization will reduce the elapsed
time to produce the overall hash.<a href="#section-4-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="const">
<section id="section-5">
      <h2 id="name-fnv-constants">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-fnv-constants" class="section-name selfRef">FNV Constants</a>
      </h2>
<p id="section-5-1">The FNV Primes are as follows:<a href="#section-5-1" class="pilcrow">¶</a></p>
<table class="center" id="table-1">
        <caption><a href="#table-1" class="selfRef">Table 1</a></caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Size FNV Prime = Expression</th>
          </tr>
          <tr>
            <th class="text-right" rowspan="1" colspan="1">= Decimal</th>
          </tr>
          <tr>
            <th class="text-right" rowspan="1" colspan="1">= Hexadecimal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">32-bit FNV_Prime = 2<sup>24</sup> + 2<sup>8</sup> + 0x93</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 16,​777,​619</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x01000193</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">64-bit FNV_Prime = 2<sup>40</sup> + 2<sup>8</sup> + 0xB3</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
1,​099,​511,​628,​211</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1"> = 0x00000100 000001B3</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">128-bit FNV_Prime = 2<sup>88</sup> + 2<sup>8</sup> + 0x3B</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
309,​485,​009,​821,​345,​068,​724,​781,​371</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x00000000 01000000 00000000
0000013B</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">256-bit FNV_Prime = 2<sup>168</sup> + 2<sup>8</sup> + 0x63</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
374,​144,​419,​156,​711,​147,​060,​143,​317,​175,​368,​453,​031,​918,​731,​002,​211</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x0000000000000000
0000010000000000 0000000000000000 0000000000000163</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">512-bit FNV_Prime = 2<sup>344</sup> + 2<sup>8</sup> + 0x57</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 35,​835,​915,​874,​844,​867,​368,​919,​076,​489,​095,​108,​449,​946,​327,​955,​754,​392,​558,​399,​825,​615,​420,​669,​938,​882,​575,​126,​094,​039,​892,​345,​713,​852,​759</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x0000000000000000
0000000000000000 0000000001000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 0000000000000157</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">1024-bit FNV_Prime = 2<sup>680</sup> + 2<sup>8</sup> + 0x8D</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 5,​016,​456,​510,​113,​118,​655,​434,​598,​811,​035,​278,​955,​030,​765,​345,​404,​790,​744,​303,​017,​523,​831,​112,​055,​108,​147,​451,​509,​157,​692,​220,​295,​382,​716,​162,​651,​878,​526,​895,​249,​385,​292,​291,​816,​524,​375,​083,​746,​691,​371,​804,​094,​271,​873,​160,​484,​737,​966,​720,​260,​389,​217,​684,​476,​157,​468,​082,​573</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000010000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 0000000000000000 000000000000018D</td>
          </tr>
        </tbody>
      </table>
<p id="section-5-3">The FNV offset_basis values are as follows:<a href="#section-5-3" class="pilcrow">¶</a></p>
<table class="center" id="table-2">
        <caption><a href="#table-2" class="selfRef">Table 2</a></caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Size offset_basis</th>
          </tr>
          <tr>
            <th class="text-right" rowspan="1" colspan="1">= Decimal</th>
          </tr>
          <tr>
            <th class="text-right" rowspan="1" colspan="1">= Hexadecimal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">32-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 2,​166,​136,​261</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x811C9DC5</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">64-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
14,​695,​981,​039,​346,​656,​037</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0xCBF29CE4 84222325</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">128-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
144,​066,​263,​297,​769,​815,​596,​495,​629,​667,​062,​367,​629</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x6C62272E 07BB0142 62B82175 6295C58D</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">256-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">=
100,​029,​257,​958,​052,​580,​907,​070,​968,​620,​625,​704,​837,​092,​796,​014,​241,​193,​945,​225,​284,​501,​741,​471,​925,​557</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0xDD268DBCAAC55036 2D98C384C4E576CC
C8B1536847B6BBB3 1023B4C8CAEE0535</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">512-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 9,​659,​303,​129,​496,​669,​498,​009,​435,​400,​716,​310,​466,​090,​418,​745,​672,​637,​896,​108,​374,​329,​434,​462,​657,​994,​582,​932,​197,​716,​438,​449,​813,​051,​892,​206,​539,​805,​784,​495,​328,​239,​340,​083,​876,​191,​928,​701,​583,​869,​517,​785</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0xB86DB0B1171F4416 DCA1E50F309990AC
AC87D059C9000000 0000000000000D21 E948F68A34C192F6 2EA79BC942DBE7CE
182036415F56E34B AC982AAC4AFE9FD9</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">1024-bit offset_basis</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 14,​197,​795,​064,​947,​621,​068,​722,​070,​641,​403,​218,​320,​880,​622,​795,​441,​933,​960,​878,​474,​914,​617,​582,​723,​252,​296,​732,​303,​717,​722,​150,​864,​096,​521,​202,​355,​549,​365,​628,​174,​669,​108,​571,​814,​760,​471,​015,​076,​148,​029,​755,​969,​804,​077,​320,​157,​692,​458,​563,​003,​215,​304,​957,​150,​157,​403,​644,​460,​363,​550,​505,​412,​711,​285,​966,​361,​610,​267,​868,​082,​893,​823,​963,​790,​439,​336,​411,​086,​884,​584,​107,​735,​010,​676,​915</td>
          </tr>
          <tr>
            <td class="text-right" rowspan="1" colspan="1">= 0x0000000000000000 005F7A76758ECC4D
32E56D5A591028B7 4B29FC4223FDADA1 6C3BF34EDA3674DA 9A21D90000000000
0000000000000000 0000000000000000 0000000000000000 0000000000000000
0000000000000000 000000000004C6D7 EB6E73802734510A 555F256CC005AE55
6BDE8CC9C6A93B21 AFF4B16C71EE90B3</td>
          </tr>
        </tbody>
      </table>
</section>
</div>
<div id="sec-cons">
<section id="section-6">
      <h2 id="name-security-considerations">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-6-1">No assertion of suitability for cryptographic applications is made
for the FNV hash algorithms.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">The use of a cryptographic hash function should be considered when
active adversaries are a factor (see <a href="#applicability" class="auto internal xref">Section 1.2</a>).<a href="#section-6-2" class="pilcrow">¶</a></p>
<div id="bang">
<section id="section-6.1">
        <h3 id="name-inducing-collisions">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-inducing-collisions" class="section-name selfRef">Inducing Collisions</a>
        </h3>
<p id="section-6.1-1">An attacker could attempt to induce collisions to cause denial or
degradation of service. Consider the following simplified example: A
hash table of n buckets is being maintained with the bucket used by
some item i determined by<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1-2">
<pre>                               hash(i) mod n
</pre><a href="#section-6.1-2" class="pilcrow">¶</a>
</div>
<p id="section-6.1-3">and with a linked list out of each bucket of the items that all
hash to that bucket. Such an arrangement might be used for the symbol
table in a compiler or for some of the routing information (i.e., a RIB
(Routing Information Base)) in a router. A large number of items
hashing to the same bucket will then likely result in much slower times to
retrieve from or update the information stored through the table for
one of those items. Typically, an attacker could arrange for the
number of distinct items being hashed to be orders of magnitude larger
than n, even if n was tens or hundreds of thousands, so collisions are
guaranteed to occur in this example regardless of the nature of the
hash function.<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<p id="section-6.1-4">There are a number of different circumstances that might surround
this example, of which the following three are illustrative:<a href="#section-6.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-5.1">If a hash function is being used in an exactly known way for the
  above scenario, including a known offset_basis such as a standard
  offset_basis specified in this document, then an adversary could
  test items offline and generate an arbitrary set of items whose
  hash table indexes would collide. Under these circumstances, the
  adversary would not have to conduct any trials of actually
  submitting items and would not have to measure performance to find
  collisions.  Submitting such a set of items would then degrade or
  deny service. For FNV, the use of an offset_basis not known by the
  adversary is adequate to defeat this case.<a href="#section-6.1-5.1" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-5.2">If the adversary cannot detect when collisions occur or when service
  is degraded, then it is sufficient for the adversary to be unable to
  predict the hash outcomes. For FNV, the use of an offset_basis not known
  by the adversary may be adequate to defend against this case.<a href="#section-6.1-5.2" class="pilcrow">¶</a>
</li>
          <li class="normal" id="section-6.1-5.3">If the adversary can detect the degradation in service caused by
  collisions in the above example and can feed large numbers of
  variable items to the process, then they can collect sets of items
  that appear to collide. Even if there are limits to the number of
  items that can be submitted, if there can be multiple trials, the
  adversary can collect multiple sets of items that collide within
  each set or one growing set of items, all of which collide. Then, by
  submitting such items, the adversary can degrade or deny
  service. That is true regardless of whether the hash function used
  is a non-cryptographic hash function such as FNV or a cryptographic
  hash function such as those specified in <span>[<a href="#FIPS202" class="cite xref">FIPS202</a>]</span> or <span>[<a href="#RFC6234" class="cite xref">RFC6234</a>]</span>. One defense in this case is to detect when a
  large number of collisions are happening (which could, but would be
  unlikely to, occur by chance) and, when that is detected, rehash the
  items with some change to the hash algorithm and use the changed
  hash algorithm for subsequent items -- for example, if FNV is being
  used, to rehash with a different offset_basis and then continue
  using that new offset_basis. There exist commercially deployed
  routers that use this technique to ameliorate excessive hash
  collisions in internal tables.<a href="#section-6.1-5.3" class="pilcrow">¶</a>
</li>
        </ul>
</section>
</div>
</section>
</div>
<section id="section-7">
      <h2 id="name-historical-notes">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-historical-notes" class="section-name selfRef">Historical Notes</a>
      </h2>
<p id="section-7-1">The FNV hash algorithm originated from an idea submitted as
  reviewer comments to the IEEE POSIX P1003.2 committee <span>[<a href="#IEEE" class="cite xref">IEEE</a>]</span> in 1991 by <span class="contact-name">Glenn Fowler</span> and <span class="contact-name">Phong Vo</span>. Subsequently, during
  a ballot round, <span class="contact-name">Landon Curt Noll</span> proposed an enhancement to their
  algorithm.  Some people tried this hash and found that it worked
  rather well. In an email message to Landon, they named it the
  "Fowler/Noll/Vo" or FNV hash from their last names in alphabetical
  order <span>[<a href="#FNV" class="cite xref">FNV</a>]</span>.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">The string used to calculate the offset_basis values (see <a href="#constoffb" class="auto internal xref">Section 2.2</a>) was selected because the person testing FNV
  with non-zero offset_basis values was looking at an email message
  from Landon and was copying his standard email signature line;
  however, they "did not see very well" <span>[<a href="#FNV" class="cite xref">FNV</a>]</span> and copied
  it incorrectly. In fact, Landon uses<a href="#section-7-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7-3">
<pre>                      chongo (Landon Curt Noll) /\oo/\
</pre><a href="#section-7-3" class="pilcrow">¶</a>
</div>
<p id="section-7-4">but, since it doesn't matter, no effort has been made to correct
  this.<a href="#section-7-4" class="pilcrow">¶</a></p>
</section>
<div id="SourceCode">
<section id="section-8">
      <h2 id="name-the-source-code">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-the-source-code" class="section-name selfRef">The Source Code</a>
      </h2>
<p id="section-8-1">The following subsections provide reference C source code <span>[<a href="#C" class="cite xref">C</a>]</span>
and a test driver with a command line interface for
FNV-1a.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2"><a href="#sec-8.2" class="auto internal xref">Section 8.2</a> provides the C header and code source files for the FNV
functions. <a href="#sec-8.3" class="auto internal xref">Section 8.3</a> provides the test driver. <a href="#sec-8.4" class="auto internal xref">Section 8.4</a> provides
a simple makefile to build the test driver or a library file with all
FNV sizes.<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">Alternative source code for 32- and 64-bit FNV is available at
<span>[<a href="#LCN2" class="cite xref">LCN2</a>]</span>. Other alternative source code, including in x86
assembler, is currently available at <span>[<a href="#FNV" class="cite xref">FNV</a>]</span>. In some
cases, this further source code has been further optimized.<a href="#section-8-3" class="pilcrow">¶</a></p>
<section id="section-8.1">
        <h3 id="name-source-code-details">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-source-code-details" class="section-name selfRef">Source Code Details</a>
        </h3>
<section id="section-8.1.1">
          <h4 id="name-fnv-functions-available">
<a href="#section-8.1.1" class="section-number selfRef">8.1.1. </a><a href="#name-fnv-functions-available" class="section-name selfRef">FNV Functions Available</a>
          </h4>
<p id="section-8.1.1-1">The functions provided are listed below. The "xxx" in the
  function names is "32", "64", "128", "256", "512", or "1024",
  depending on the length of the FNV.  All of the FNV hash functions
  have as their return value an integer whose meaning is specified in
  FNVErrorCodes.h.<a href="#section-8.1.1-1" class="pilcrow">¶</a></p>
<p id="section-8.1.1-2">Functions providing a byte vector hash are available for all
  lengths. For FNV-32, versions are available that provide a 32-bit
  integer and are identified by replacing "xxx" with "32INT". For
  example, FNV32string provides a 4-byte vector, but FNV32INTstring
  provides a 32-bit integer. For FNV-64, if compiled with 64-bit
  integers enabled (i.e., FNV_64bitIntegers defined; see FNVconfig.h),
  versions are available that provide a 64-bit integer and are
  identified by replacing "xxx" with "64INT". Versions providing an
  integer hash will not be compatible between systems of different
  endianness (see <a href="#endian" class="auto internal xref">Section 2.3</a>).<a href="#section-8.1.1-2" class="pilcrow">¶</a></p>
<p id="section-8.1.1-3">If you want to copy the source code from this document, note that
  it is indented by three spaces in the ".txt" version. It may be
  simplest to copy from the ".html" version of this document.<a href="#section-8.1.1-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-8.1.1-4">
            <dt id="section-8.1.1-4.1">FNVxxxstring, FNVxxxblock, FNVxxxfile:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.2"></dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.3">FNVxxxstringBasis, FNVxxxblockBasis, FNVxxxfileBasis:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.4"></dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.5">FNVxxxINTstring, FNVxxxINTblock, FNVxxxINTfile:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.6"></dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.7">FNVxxxINTstringBasis, FNVxxxINTblockBasis,
    FNVxxxINTfileBasis:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.8">These are simple functions for directly returning the FNV hash
    of a zero-terminated byte string not including that zero byte, the
    FNV hash of a counted block of bytes, and the FNV of a file,
    respectively. The functions whose names have the "Basis" suffix take
    an additional parameter specifying the offset_basis. Note that for
    applications of FNV-32 and of FNV-64 where integers of that size
    are supported and an integer data type output is acceptable, the
    code is sufficiently simple that, to maximize performance, the use of
    open coding or macros may be more appropriate than calling a
    subroutine.<a href="#section-8.1.1-4.8" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.9">FNVxxxinit, FNVxxxinitBasis:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.10"></dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.11">FNVxxxINTinitBasis:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.12">These functions and the next two
    sets of functions below provide facilities for incrementally
    calculating FNV hashes. They all assume a data structure of type
    FNVxxxcontext that holds the current state of the hash. FNVxxxinit
    initializes that context to the standard
    offset_basis. FNVxxxinitBasis takes an offset_basis value as a
    parameter and may be useful for hashing concatenations, as
    described in <a href="#sec-4" class="auto internal xref">Section 4</a>, as well as for simply using a non-standard
    offset_basis.<a href="#section-8.1.1-4.12" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.13">FNVxxxblockin, FNVxxxstringin, FNVxxxfilein:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.14">These
    functions hash a sequence of bytes into an FNVxxxcontext that was
    originally initialized by FNVxxxinit or
    FNVxxxinitBasis. FNVxxxblockin hashes in a counted block of
    bytes. FNVxxxstringin hashes in a zero-terminated byte string not
    including the final zero byte. FNVxxxfilein hashes in the contents
    of a file.<a href="#section-8.1.1-4.14" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.1-4.15">FNVxxxresult, FNVxxxINTresult:</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.1-4.16">This function extracts
    the final FNV hash result from an FNVxxxcontext.<a href="#section-8.1.1-4.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
</section>
<section id="section-8.1.2">
          <h4 id="name-source-files-and-64-bit-sup">
<a href="#section-8.1.2" class="section-number selfRef">8.1.2. </a><a href="#name-source-files-and-64-bit-sup" class="section-name selfRef">Source Files and 64-Bit Support</a>
          </h4>
<p id="section-8.1.2-1">Code optimized for 64-bit integer support -- that is, support of
64-bit integer addition and 32-bit x 32-bit multiplication producing a
64-bit product -- is provided based on whether or not the
FNV_64bitIntegers symbol is defined. By default, this is set in
FNVconfig.h based on the compilation target; however, this can be
overridden by editing that file or by defining certain symbols in, for
example, a command line invoking a compilation.<a href="#section-8.1.2-1" class="pilcrow">¶</a></p>
<p id="section-8.1.2-2">For support of a single FNV size, say "xxx" (e.g., FNV64), in an application, the
application itself needs to include the appropriate FNVxxx.h file (which will, in turn,
include the FNVconfig.h and FNVErrorCodes.h files).  To build the
particular FNVxxx code itself, compile the FNVxxx.c file with
the following files available to the compiler: FNVconfig.h, fnv-private.h, FNVErrorCodes.h, and FNVxxx.h. (See <a href="#sec-8.2" class="auto internal xref">Section 8.2</a>.) Since the test program provided in <a href="#sec-8.3" class="auto internal xref">Section 8.3</a> uses all sizes of FNV, all the .c and .h files are needed to compile it.<a href="#section-8.1.2-2" class="pilcrow">¶</a></p>
</section>
<div id="sec-8.1.3">
<section id="section-8.1.3">
          <h4 id="name-command-line-interface">
<a href="#section-8.1.3" class="section-number selfRef">8.1.3. </a><a href="#name-command-line-interface" class="section-name selfRef">Command Line Interface</a>
          </h4>
<p id="section-8.1.3-1">The test program provided in <a href="#sec-8.3" class="auto internal xref">Section 8.3</a> has a command line
    interface. By default, with no command line arguments, it runs
    tests of all FNV lengths. Command line options are as follows:<a href="#section-8.1.3-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.1.3-2">
<pre>   FNVhash [-a] [-h] [-t nnn] [-u nnn] [-v] [-f filename] [token ...]
</pre><a href="#section-8.1.3-2" class="pilcrow">¶</a>
</div>
<p id="section-8.1.3-3">The option letters have the following meanings:<a href="#section-8.1.3-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="section-8.1.3-4">
            <dt id="section-8.1.3-4.1">-a</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.2">Run tests for all lengths.<a href="#section-8.1.3-4.2" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.3">-h</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.4">Print a help message about the command line.<a href="#section-8.1.3-4.4" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.5">-v</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.6">Complement the Verbose flag, which is initially
  off. When the flag is on, the program prints more information during
  tests, etc.<a href="#section-8.1.3-4.6" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.7">-t nnn</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.8">Run tests for length nnn, which must be one of 32,
  64, 128, 256, 512, or 1024.<a href="#section-8.1.3-4.8" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.9">-u nnn</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.10">Use hash size nnn, which must be one of 32, 64,
  128, 256, 512, or 1024. This is useful for setting the hash size for use
  by the -f option or in hashing tokens on the command line after the
  options.<a href="#section-8.1.3-4.10" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.11">-f filename</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.12">Hash the contents of the file with name
  filename. The hash size must have been set by a prior -t or -u
  option in the command line.<a href="#section-8.1.3-4.12" class="pilcrow">¶</a>
</dd>
            <dd class="break"></dd>
<dt id="section-8.1.3-4.13">token</dt>
            <dd style="margin-left: 1.5em" id="section-8.1.3-4.14">Tokens appearing on the command line after the
  options are hashed with the current hash size, which must have been
  set by a prior -t or -u option in the command line.<a href="#section-8.1.3-4.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
</dl>
<p id="section-8.1.3-5">For example,<a href="#section-8.1.3-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.1.3-6">
<pre>      FNVhash -t 128 -h -v -t 64 -v -u 256 -f foobar.txt RabOof 1234
</pre><a href="#section-8.1.3-6" class="pilcrow">¶</a>
</div>
<p id="section-8.1.3-7">runs tests for FNV128, then prints a command line help message,
then turns on Verbose, then runs the tests for FNV64, then turns off
Verbose, then sets the hash size to 256, then hashes the contents of
file foobar.txt, then hashes the token "RabOof", and finally hashes
the token "1234".<a href="#section-8.1.3-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
<div id="sec-8.2">
<section id="section-8.2">
        <h3 id="name-fnv-1a-c-code">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-fnv-1a-c-code" class="section-name selfRef">FNV-1a C Code</a>
        </h3>
<p id="section-8.2-1">This section provides the direct FNV-1a function for each of the
  lengths for which it is specified in this document.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<p id="section-8.2-2">The following is a configuration header to set whether 64-bit
integers are supported and establish an enum used for return
values.<a href="#section-8.2-2" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2-3">
<pre>&lt;CODE BEGINS&gt; file "FNVconfig.h"

//************************ FNVconfig.h **************************//
//**************** See RFC 9923 for details. ********************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNVconfig_H_
#define _FNVconfig_H_

/*
 *  Description:
 *      This file provides configuration ifdefs for the
 *      FNV-1a non-cryptographic hash algorithms. */

/*      FNV_64bitIntegers - Define this if your system supports
 *          64-bit arithmetic including 32-bit x 32-bit
 *          multiplication producing a 64-bit product.  If
 *          undefined, it will be assumed that 32-bit arithmetic
 *          is supported including 16-bit x 16-bit multiplication
 *          producing a 32-bit result.
 */

#include &lt;stdint.h&gt;

/* Check if 64-bit integers are supported in the target */

#ifdef UINT64_MAX
    #define FNV_64bitIntegers
#else
    #undef FNV_64bitIntegers
#endif

/*      The following allows overriding the
 *      above configuration setting.
 */

#ifdef FNV_TEST_PROGRAM
# ifdef TEST_FNV_64bitIntegers
#  ifndef FNV_64bitIntegers
#   define FNV_64bitIntegers
#  endif
# else
#  undef FNV_64bitIntegers
# endif
# ifndef FNV_64bitIntegers /* causes an error if uint64_t is used */
#  undef uint64_t
#  define uint64_t no_64_bit_integers
# endif
#endif

#endif /* _FNVconfig_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2-3" class="pilcrow">¶</a>
</div>
<p id="section-8.2-4">The following code is a simple header file to define the return
value error codes for the FNV routines.<a href="#section-8.2-4" class="pilcrow">¶</a></p>
<div class="lang-c sourcecode" id="section-8.2-5">
<pre>&lt;CODE BEGINS&gt; file "FNVErrorCodes.h"

//********************** FNVErrorCodes.h **************************//
//**************** See RFC 9923 for details. **********************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV_ErrCodes_
#define _FNV_ErrCodes_
//****************************************************************//
//
//  All FNV functions, except the FNVxxxfile functions,
//    return an integer as follows:
//       0 -&gt; success
//      &gt;0 -&gt; error as listed below
//
enum {    /* success and errors */
    fnvSuccess = 0,
    fnvNull,        // 1 Null pointer parameter
    fnvStateError,  // 2 called Input after Result or before Init
    fnvBadParam     // 3 passed a bad parameter
};
#endif /* _FNV_ErrCodes_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2-5" class="pilcrow">¶</a>
</div>
<p id="section-8.2-6">The following code is a private header file that is used by all the FNV
  functions further below and that states the terms for use and
  redistribution of all of this source code.<a href="#section-8.2-6" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2-7">
<pre>&lt;CODE BEGINS&gt; file "fnv-private.h"

//************************ fnv-private.h **************************//
//****************** See RFC 9923 for details. ********************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *
 * *  Neither the name of Internet Society, IETF or IETF Trust, nor
 *    the names of specific contributors, may be used to endorse or
 *    promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _FNV_PRIVATE_H_
#define _FNV_PRIVATE_H_

/*
 *      Six FNV-1a hashes are defined with these sizes:
 *              FNV32          32 bits, 4 bytes
 *              FNV64          64 bits, 8 bytes
 *              FNV128         128 bits, 16 bytes
 *              FNV256         256 bits, 32 bytes
 *              FNV512         512 bits, 64 bytes
 *              FNV1024        1024 bits, 128 bytes
 */

/* Private stuff used by this implementation of the FNV
 * (Fowler/Noll/Vo) non-cryptographic hash function FNV-1a.
 * External callers don't need to know any of this. */

enum {  /* State value bases for context-&gt;Computed */
    FNVinited = 22,
    FNVcomputed = 76,
    FNVemptied = 220,
    FNVclobber = 122 /* known bad value for testing */
};

/* Deltas to assure distinct state values for different lengths */
enum {
   FNV32state = 1,
   FNV64state = 3,
   FNV128state = 5,
   FNV256state = 7,
   FNV512state = 11,
   FNV1024state = 13
};

#endif /* _FNV_PRIVATE_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2-7" class="pilcrow">¶</a>
</div>
<section id="section-8.2.1">
          <h4 id="name-fnv32-code">
<a href="#section-8.2.1" class="section-number selfRef">8.2.1. </a><a href="#name-fnv32-code" class="section-name selfRef">FNV32 Code</a>
          </h4>
<p id="section-8.2.1-1">The following code is the header and C source for 32-bit FNV-1a providing a 32-bit
integer or 4-byte vector hash.<a href="#section-8.2.1-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.1-2">
<pre>&lt;CODE BEGINS&gt; file "FNV32.h"

//*************************** FNV32.h ****************************//
//****************** See RFC 9923 for details. *******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV32_H_
#define _FNV32_H_

/*
 *  Description:
 *      This file provides headers for the 32-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV32size (32/8)
#define FNV32basis 0x811C9DC5

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint32_t    unsigned 32-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV32 hash
 */
typedef struct FNV32context_s {
    int Computed;  /* state */
    uint32_t Hash;
} FNV32context;

/*  Function Prototypes:
 *
 *    FNV32string: hash a zero-terminated string not including
 *                 the terminating zero
 *    FNV32stringBasis: also takes an offset_basis parameter
 *
 *    FNV32block: hash a byte vector of a specified length
 *    FNV32blockBasis: also takes an offset_basis parameter
 *
 *    FNV32file: hash the contents of a file
 *    FNV32fileBasis: also takes an offset_basis parameter
 *
 *    FNV32init:  initializes an FNV32 context
 *    FNV32initBasis: initializes an FNV32 context with a
 *                    provided 4-byte vector basis
 *    FNV32blockin:  hash in a byte vector of a specified length
 *    FNV32stringin: hash in a zero-terminated string not
 *                   including the terminating zero
 *    FNV32filein: hash in the contents of a file
 *    FNV32result: returns the hash value
 *
 * Hash is returned as a 4-byte vector by the functions above,
 *    and the following return a 32-bit unsigned integer:
 *
 *    FNV32INTstring: hash a zero-terminated string not including
 *                 the terminating zero
 *    FNV32INTstringBasis: also takes an offset_basis parameter
 *
 *    FNV32INTblock: hash a byte vector of a specified length
 *    FNV32INTblockBasis: also takes an offset_basis parameter
 *
 *    FNV32INTfile: hash the contents of a file
 *    FNV32INTfileBasis: also takes an offset_basis parameter
 *
 *    FNV32INTinitBasis: initializes an FNV32 context with a
 *                     provided 32-bit integer basis
 *    FNV32INTresult: returns the hash value
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV32 */
extern int FNV32INTstring ( const char *in,
                            uint32_t * const out );
extern int FNV32INTstringBasis ( const char *in,
                                 uint32_t * const out,
                                 uint32_t basis );
extern int FNV32string ( const char *in,
                         uint8_t out[FNV32size] );
extern int FNV32stringBasis ( const char *in,
                              uint8_t out[FNV32size],
                              const uint8_t basis[FNV32size] );
extern int FNV32INTblock ( const void *vin,
                           long int length,
                           uint32_t * const out );
extern int FNV32INTblockBasis ( const void *vin,
                                long int length,
                                uint32_t * const out,
                                uint32_t basis );
extern int FNV32block ( const void *vin,
                        long int length,
                        uint8_t out[FNV32size] );
extern int FNV32blockBasis ( const void *vin,
                             long int length,
                             uint8_t out[FNV32size],
                             const uint8_t basis[FNV32size] );
extern int FNV32INTfile ( const char *fname,
                          uint32_t * const out );
extern int FNV32INTfileBasis ( const char *fname,
                               uint32_t * const out,
                               uint32_t basis );
extern int FNV32file ( const char *fname,
                       uint8_t out[FNV32size] );
extern int FNV32fileBasis ( const char *fname,
                            uint8_t out[FNV32size],
                            const uint8_t basis[FNV32size] );
extern int FNV32init ( FNV32context * const );
extern int FNV32INTinitBasis ( FNV32context * const,
                               uint32_t basis );
extern int FNV32initBasis ( FNV32context * const,
                            const uint8_t basis[FNV32size] );
extern int FNV32blockin ( FNV32context * const,
                          const void *vin,
                          long int length );
extern int FNV32stringin ( FNV32context * const,
                           const char *in );
extern int FNV32filein ( FNV32context * const,
                         const char *fname );
extern int FNV32INTresult ( FNV32context * const,
                            uint32_t * const out );
extern int FNV32result ( FNV32context * const,
                         uint8_t out[FNV32size] );

#ifdef __cplusplus
}
#endif

#endif /* _FNV32_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.1-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.1-3">
<pre>&lt;CODE BEGINS&gt; file "FNV32.c"

//************************** FNV32.c **************************//
//**************** See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This code implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 32-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "fnv-private.h"
#include "FNV32.h"

/* 32-bit FNV_prime = 2^24 + 2^8 + 0x93 */
#define FNV32prime 0x01000193

/* FNV32: hash a zero-terminated string not including the zero
*****************************************************************/
int FNV32INTstring ( const char *in, uint32_t * const out ) {
    return FNV32INTstringBasis ( in, out, FNV32basis );
}   /* end FNV32INTstring */

/* FNV32: hash a zero-terminated string not including the zero
 * with a non-standard basis
*****************************************************************/
int FNV32INTstringBasis ( const char *in,
                          uint32_t * const out,
                          uint32_t basis ) {
    uint8_t     ch;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    while ( (ch = *in++) )
        basis = FNV32prime * ( basis ^ ch );
    *out = basis;
    return fnvSuccess;
}   /* end FNV32INTstringBasis */

/* FNV32: hash a zero-terminated string not including the zero
*****************************************************************/
int FNV32string ( const char *in, uint8_t out[FNV32size] ) {
    uint32_t    temp;
    uint8_t     ch;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    temp = FNV32basis;
    while ( (ch = *in++) )
        temp = FNV32prime * ( temp ^ ch );
    for ( int i=0; i&lt;FNV32size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV32string */

/* FNV32: hash a zero-terminated string not including the zero
 * with a non-standard basis
*****************************************************************/
int FNV32stringBasis ( const char *in,
                       uint8_t out[FNV32size],
                       const uint8_t basis[FNV32size] ) {
    uint32_t temp;
    int i;
    uint8_t ch;

    if ( !in || !out || !basis )
        return fnvNull; /* Null input pointer */
    temp = basis[0]+(basis[1]&lt;&lt;8)+(basis[2]&lt;&lt;16)+(basis[3]&lt;&lt;24);
    while ( (ch = *in++) )
        temp = FNV32prime * ( temp ^ ch );
    out[0] = temp &amp; 0xFF;
    for ( i=1; i&lt;FNV32size; ++i ) {
        temp &gt;&gt;= 8;
        out[i] = temp &amp; 0xFF;
    }
    return fnvSuccess;
}   /* end FNV32stringBasis */

/* FNV32: hash a counted block returning an integer
 ****************************************************************/
int FNV32INTblock ( const void *vin,
                   long int length,
                   uint32_t * const out ) {
    return FNV32INTblockBasis ( vin, length, out, FNV32basis );
}   /* end FNV32INTblock */

/* FNV32: hash a counted block with a non-standard basis
 ****************************************************************/
int FNV32INTblockBasis ( const void *vin,
                 long int length,
                 uint32_t * const out,
                 uint32_t basis ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    for ( temp = basis; length &gt; 0; length-- )
        temp = FNV32prime * ( temp ^ *in++ );
    *out = temp;
    return fnvSuccess;
}   /* end FNV32INTblockBasis */

/* FNV32: hash a counted block returning a 4-byte vector
 ****************************************************************/
int FNV32block ( const void *vin,
                 long int length,
                 uint8_t out[FNV32size] ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    for ( temp = FNV32basis; length &gt; 0; length-- )
        temp = FNV32prime * ( temp ^ *in++ );
    for ( int i=0; i&lt;FNV32size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV32block */

/* FNV32: hash a counted block with a non-standard basis
 ****************************************************************/
int FNV32blockBasis ( const void *vin,
                 long int length,
                 uint8_t out[FNV32size],
                 const uint8_t basis[FNV32size] ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp;

    if ( !in || !out || !basis )
        return fnvNull; /* Null input pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    temp = basis[0]+(basis[1]&lt;&lt;8)+(basis[2]&lt;&lt;16)+(basis[3]&lt;&lt;24);
    for ( ; length &gt; 0; length-- )
        temp = FNV32prime * ( temp ^ *in++ );
    for ( int i=0; i&lt;FNV32size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV32blockBasis */

/* hash the contents of a file, return 32-bit integer
 ******************************************************************/
int FNV32INTfile ( const char *fname,
                   uint32_t * const out ) {
    return FNV32INTfileBasis ( fname, out, FNV32basis );
}   /* end FNV32INTfile */

/* hash the contents of a file, return 32-bit integer
 * with a non-standard basis
 ******************************************************************/
int FNV32INTfileBasis ( const char *fname,
                        uint32_t * const out,
                        uint32_t basis ) {
    FNV32context e32Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV32INTinitBasis ( &amp;e32Context, basis )) )
        return error;
    if ( (error = FNV32filein ( &amp;e32Context, fname )) )
        return error;
    return FNV32INTresult ( &amp;e32Context, out );
}   /* end FNV32INTfileBasis */

/* hash the contents of a file, return 4-byte vector
 ******************************************************************/
int FNV32file ( const char *fname,
                uint8_t out[FNV32size] ) {
    FNV32context e32Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV32init (&amp;e32Context)) )
        return error;
    if ( (error = FNV32filein ( &amp;e32Context, fname)) )
        return error;
    return FNV32result ( &amp;e32Context, out );
}   /* end FNV32file */

/* hash the contents of a file, return 4-byte vector
 * with a non-standard basis
 ******************************************************************/
int FNV32fileBasis ( const char *fname,
                     uint8_t out[FNV32size],
                     const uint8_t basis[FNV32size] ) {
    FNV32context e32Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV32initBasis (&amp;e32Context, basis)) )
        return error;
    if ( (error = FNV32filein ( &amp;e32Context, fname)) )
        return error;
    return FNV32result ( &amp;e32Context, out );
}   /* end FNV32fileBasis */

//**************************************************************
//       Set of init, input, and output functions below
//       to incrementally compute FNV32
//**************************************************************

/* initialize context
 ***************************************************************/
int FNV32init ( FNV32context * const ctx ) {
    return FNV32INTinitBasis ( ctx, FNV32basis );
}   /* end FNV32init */

/* initialize context with a provided 32-bit integer basis
 ***************************************************************/
int FNV32INTinitBasis ( FNV32context * const ctx,
                        uint32_t basis ) {
    if ( !ctx )
        return fnvNull;
    ctx-&gt;Hash = basis;
    ctx-&gt;Computed = FNVinited+FNV32state;
    return fnvSuccess;
}   /* end FNV32INTinitBasis */

/* initialize context with a provided 4-byte vector basis
 ***************************************************************/
int FNV32initBasis ( FNV32context * const ctx,
                     const uint8_t basis[FNV32size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    ctx-&gt;Hash =
        basis[0]+(basis[1]&lt;&lt;8)+(basis[2]&lt;&lt;16)+(basis[3]&lt;&lt;24);
    ctx-&gt;Computed = FNVinited+FNV32state;
    return fnvSuccess;
}   /* end FNV32initBasis */

/* hash in a counted block
 ***************************************************************/
int FNV32blockin ( FNV32context * const ctx,
                   const void *vin,
                   long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV32state:
            ctx-&gt;Computed = FNVcomputed+FNV32state;
            break;
        case FNVcomputed+FNV32state:
            break;
        default:
            return fnvStateError;
    }
    for ( temp = ctx-&gt;Hash; length &gt; 0; length-- )
        temp = FNV32prime * ( temp ^ *in++ );
    ctx-&gt;Hash = temp;
    return fnvSuccess;
}   /* end FNV32blockin */

/* hash in a zero-terminated string not including the zero
 ***************************************************************/
int FNV32stringin ( FNV32context * const ctx, const char *in ) {
    uint32_t temp;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV32state:
            ctx-&gt;Computed = FNVcomputed+FNV32state;
            break;
        case FNVcomputed+FNV32state:
            break;
        default:
            return fnvStateError;
    }
    temp = ctx-&gt;Hash;
    while ( (ch = (uint8_t)*in++) )
        temp = FNV32prime * ( temp ^ ch );
    ctx-&gt;Hash = temp;
    return fnvSuccess;
}   /* end FNV32stringin */

/* hash in the contents of a file
 ******************************************************************/
int FNV32filein ( FNV32context * const e32Context,
                  const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e32Context || !fname )
        return fnvNull;
    switch ( e32Context-&gt;Computed ) {
        case FNVinited+FNV32state:
            e32Context-&gt;Computed = FNVcomputed+FNV32state;
            break;
        case FNVcomputed+FNV32state:
            break;
        default:
            return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV32blockin ( e32Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error = FNV32blockin ( e32Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error) return fnvBadParam;
    return fnvSuccess;
}   /* end FNV32filein */

/* return hash as an integer
 ***************************************************************/
int FNV32INTresult ( FNV32context * const ctx,
                     uint32_t * const out ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV32state )
        return fnvStateError;
    ctx-&gt;Computed = FNVemptied+FNV32state;
    *out = ctx-&gt;Hash;
    ctx-&gt;Hash = 0;
    return fnvSuccess;
}   /* end FNV32INTresult */

/* return hash as a 4-byte vector
 ***************************************************************/
int FNV32result ( FNV32context * const ctx,
                  uint8_t out[FNV32size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV32state )
        return fnvStateError;
    ctx-&gt;Computed = FNVemptied+FNV32state;
    for ( int i=0; i&lt;FNV32size; ++i )
        out[i] = ((uint8_t *)&amp;ctx-&gt;Hash)[i];
    ctx-&gt;Hash = 0;
    return fnvSuccess;
}   /* end FNV32result */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.1-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-8.2.2">
          <h4 id="name-fnv64-code">
<a href="#section-8.2.2" class="section-number selfRef">8.2.2. </a><a href="#name-fnv64-code" class="section-name selfRef">FNV64 Code</a>
          </h4>
<p id="section-8.2.2-1">The following code is the header and C source for 64-bit FNV-1a providing an 8-byte
vector or, optionally, if 64-bit integers are supported, a 64-bit
integer hash.<a href="#section-8.2.2-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.2-2">
<pre>&lt;CODE BEGINS&gt; file "FNV64.h"

//*************************** FNV64.h ****************************//
//***************** See RFC 9923 for details. ********************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV64_H_
#define _FNV64_H_

/*
 *  Description:
 *      This file provides headers for the 64-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV64size (64/8)
#ifdef FNV_64bitIntegers
#define FNV64basis 0xCBF29CE484222325
#endif

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint64_t    unsigned 64-bit integer (ifdef FNV_64bitIntegers)
 *  uint32_t    unsigned 32-bit integer
 *  uint16_t    unsigned 16-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV64 hash
 */
#ifdef FNV_64bitIntegers
    /* version if 64-bit integers supported */
typedef struct FNV64context_s {
        int Computed;  /* state */
        uint64_t Hash;
} FNV64context;

#else
    /* version if 64-bit integers NOT supported */
typedef struct FNV64context_s {
        int Computed;  /* state */
        uint16_t Hash[FNV64size/2];
} FNV64context;

#endif /* FNV_64bitIntegers */

/*  Function Prototypes:
 *
 *    FNV64string: hash a zero-terminated string not including
 *                 the terminating zero
 *    FNV64stringBasis: also takes an offset_basis parameter
 *
 *    FNV64block: hash a byte vector of a specified length
 *    FNV64blockBasis: also takes an offset_basis parameter
 *
 *    FNV64file: hash the contents of a file
 *    FNV64fileBasis: also takes an offset_basis parameter
 *
 *    FNV64init: initializes an FNV64 context
 *    FNV64initBasis: initializes an FNV64 context with a
 *                    provided 8-byte vector basis
 *    FNV64blockin: hash in a byte vector of a specified length
 *    FNV64stringin: hash in a zero-terminated string not
 *                   including the terminating zero
 *    FNV64filein: hash in the contents of a file
 *    FNV64result: returns the hash value
 *
 * Hash is returned as an 8-byte vector by the functions above.
 *    If 64-bit integers are supported, the following return
 *    a 64-bit integer.
 *
 *    FNV64INTstring: hash a zero-terminated string not including
 *                 the terminating zero
 *    FNV64INTstringBasis: also takes an offset_basis parameter
 *
 *    FNV64INTblock: hash a byte vector of a specified length
 *    FNV64INTblockBasis: also takes an offset_basis parameter
 *
 *    FNV64INTfile: hash the contents of a file
 *    FNV64INTfileBasis: also takes an offset_basis parameter
 *
 *    FNV64INTinitBasis: initializes an FNV64 context with a
 *                     provided 64-bit integer basis
 *    FNV64INTresult: returns the hash value
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV64 */
extern int FNV64string ( const char *in,
                         uint8_t out[FNV64size] );
extern int FNV64stringBasis ( const char *in,
                              uint8_t out[FNV64size],
                              const uint8_t basis[FNV64size] );
extern int FNV64block ( const void *vin,
                        long int length,
                        uint8_t out[FNV64size] );
extern int FNV64blockBasis ( const void *vin,
                             long int length,
                             uint8_t out[FNV64size],
                             const uint8_t basis[FNV64size] );
extern int FNV64file ( const char * fname,
                       uint8_t out[FNV64size] );
extern int FNV64fileBasis ( const char * fname,
                            uint8_t out[FNV64size],
                            const uint8_t basis[FNV64size] );
extern int FNV64init ( FNV64context * const );
extern int FNV64initBasis ( FNV64context * const,
                            const uint8_t basis[FNV64size] );
extern int FNV64blockin ( FNV64context * const,
                          const void * vin,
                          long int length );
extern int FNV64stringin ( FNV64context * const,
                           const char * in );
extern int FNV64filein ( FNV64context * const,
                        const char *fname );
extern int FNV64result ( FNV64context * const,
                         uint8_t out[FNV64size] );

#ifdef FNV_64bitIntegers
  extern int FNV64INTstring ( const char *in,
                              uint64_t * const out );
  extern int FNV64INTstringBasis ( const char *in,
                                   uint64_t * const out,
                                   uint64_t basis );
  extern int FNV64INTblock ( const void *vin,
                             long int length,
                             uint64_t * const out );
  extern int FNV64INTblockBasis ( const void *vin,
                                  long int length,
                                  uint64_t * const out,
                                  uint64_t basis );
  extern int FNV64INTfile ( const char * fname,
                            uint64_t * const out );
  extern int FNV64INTfileBasis ( const char * fname,
                                 uint64_t * const out,
                                 uint64_t basis );
  extern int FNV64INTinitBasis ( FNV64context * const,
                                 uint64_t basis );
  extern int FNV64INTresult ( FNV64context * const,
                              uint64_t * const out );
#endif /* FNV_64bitIntegers */

#ifdef __cplusplus
}
#endif

#endif /* _FNV64_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.2-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.2-3">
<pre>&lt;CODE BEGINS&gt; file "FNV64.c"

//*************************** FNV64.c ****************************//
//****************** See RFC 9923 for details. *******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This file implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 64-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "FNVconfig.h"
#include "fnv-private.h"
#include "FNV64.h"

//*****************************************************************
// CODE THAT IS THE SAME FOR 32-BIT and 64-BIT ARITHMETIC
//*****************************************************************

/* hash the contents of a file, return byte vector
 ******************************************************************/
int FNV64file ( const char *fname,
                uint8_t out[FNV64size] ) {
    FNV64context e64Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV64init (&amp;e64Context)) )
        return error;
    if ( (error = FNV64filein (&amp;e64Context, fname)) )
        return error;
    return FNV64result (&amp;e64Context, out);
}   /* end FNV64file */

/* hash the contents of a file, return 64-bit integer
 * with a non-standard basis
 ******************************************************************/
int FNV64fileBasis ( const char *fname,
                     uint8_t out[FNV64size],
                     const uint8_t basis[FNV64size] ) {
    FNV64context e64Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV64initBasis (&amp;e64Context, basis)) )
        return error;
    if ( (error = FNV64filein (&amp;e64Context, fname)) )
        return error;
    return FNV64result (&amp;e64Context, out);
}   /* end FNV64fileBasis */

/* hash in the contents of a file
 ******************************************************************/
int FNV64filein ( FNV64context * const e64Context,
                  const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e64Context || !fname )
        return fnvNull;
    switch ( e64Context-&gt;Computed ) {
        case FNVinited+FNV64state:
            e64Context-&gt;Computed = FNVcomputed+FNV64state;
            break;
        case FNVcomputed+FNV64state:
            break;
        default:
            return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV64blockin ( e64Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error = FNV64blockin ( e64Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error)
        return fnvBadParam;
    return fnvSuccess;
}

//*****************************************************************
// START VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//*****************************************************************
#ifdef FNV_64bitIntegers

/* 64-bit FNV_prime = 2^40 + 2^8 + 0xb3 */
#define FNV64prime 0x00000100000001B3

/* FNV64: hash a zero-terminated string not including the zero
 * to a 64-bit integer  (64-bit)
 ******************************************************************/
int FNV64INTstring ( const char *in, uint64_t * const out ) {
    return FNV64INTstringBasis ( in, out, FNV64basis );
}   /* end FNV64INTstring */

/* FNV64: hash a zero-terminated string not including the zero
 * to a 64-bit integer  (64-bit) with a non-standard basis
 ******************************************************************/
int FNV64INTstringBasis ( const char *in,
                          uint64_t * const out,
                          uint64_t basis ) {
    uint64_t temp;
    uint8_t ch;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    temp = basis;
    while ( (ch = *in++) )
        temp = FNV64prime * ( temp ^ ch );
    *out = temp;
    return fnvSuccess;
}   /* end FNV64INTstringBasis */

/* FNV64: hash a zero-terminated string to a 64-bit integer
 * to a byte vector  (64-bit)
 ******************************************************************/
int FNV64string ( const char *in, uint8_t out[FNV64size] ) {
    uint64_t temp;
    uint8_t ch;

    if ( !in || !out )
        return fnvNull; /* Null input pointer */
    temp = FNV64basis;
    while ( (ch = *in++) )
        temp = FNV64prime * ( temp ^ ch );
    for ( int i=0; i&lt;FNV64size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV64string */

/* FNV64: hash a zero-terminated string to a 64-bit integer
 * to a byte vector  (64-bit) with a non-standard basis
 ******************************************************************/
int FNV64stringBasis ( const char *in,
                       uint8_t out[FNV64size],
                       const uint8_t basis[FNV64size] ) {
    uint64_t temp;
    int i;
    uint8_t ch;

    if ( !in || !out || !basis )
        return fnvNull; /* Null input pointer */
    temp = basis[7];
    for ( i = FNV64size-2; i&gt;=0; --i )
        temp = (temp&lt;&lt;8) + basis[i];
    while ( (ch = *in++) )
        temp = FNV64prime * ( temp ^ ch );
    for ( i=0; i&lt;FNV64size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV64stringBasis */

/* FNV64: hash a counted block to a 64-bit integer  (64-bit)
 ******************************************************************/
int FNV64INTblock ( const void *vin,
                    long int length,
                    uint64_t * const out ) {
    return FNV64INTblockBasis ( vin, length, out, FNV64basis );
}   /* end FNV64INTblock */

/* FNV64: hash a counted block to a 64-bit integer  (64-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV64INTblockBasis ( const void *vin,
                         long int length,
                         uint64_t * const out,
                         uint64_t basis ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp;

    if ( !in || !out )
        return fnvNull;
               /* Null input pointer or null output pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    for ( temp = basis; length &gt; 0; length-- )
        temp = FNV64prime * ( temp ^ *in++ );
    *out = temp;
    return fnvSuccess;
}   /* end FNV64INTblockBasis */

/* FNV64: hash a counted block to a byte vector  (64-bit)
 ******************************************************************/
int FNV64block ( const void *vin,
                 long int length,
                 uint8_t out[FNV64size] ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp;

    if ( !in || !out )
        return fnvNull;
               /* Null input pointer or null output pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    for ( temp = FNV64basis; length &gt; 0; length-- )
        temp = FNV64prime * ( temp ^ *in++ );
    for ( int i=0; i&lt;FNV64size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV64block */

/* FNV64: hash a counted block to a byte vector  (64-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV64blockBasis ( const void *vin,
                      long int length,
                      uint8_t out[FNV64size],
                      const uint8_t basis[FNV64size] ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp;
    int i;

    if ( !in || !out || !basis )
        return fnvNull;
               /* Null input pointer or null output pointer */
    if ( length &lt; 0 )
        return fnvBadParam;
    temp = basis[7];
    for ( i = FNV64size-2; i&gt;=0; --i )
        temp = (temp&lt;&lt;8) + basis[i];
    for (; length &gt; 0; length-- )
        temp = FNV64prime * ( temp ^ *in++ );
    for ( i=0; i&lt;FNV64size; ++i )
        out[i] = ((uint8_t *)&amp;temp)[i];
    return fnvSuccess;
}   /* end FNV64blockBasis */

//*****************************************************************
//       Set of init, input, and output functions below
//       to incrementally compute FNV64
//*****************************************************************

/* initialize context  (64-bit)
 ******************************************************************/
int FNV64init( FNV64context * const ctx ) {
    return FNV64INTinitBasis ( ctx, FNV64basis );
}       /* end FNV64init */

/* initialize context with a provided 64-bit integer basis  (64-bit)
 ******************************************************************/
int FNV64INTinitBasis( FNV64context * const ctx, uint64_t basis ) {
    if ( !ctx )
        return fnvNull;
    ctx-&gt;Hash = basis;
    ctx-&gt;Computed = FNVinited+FNV64state;
    return fnvSuccess;
}   /* end FNV64INTinitBasis */

/* initialize context with a provided 8-byte vector basis  (64-bit)
 ******************************************************************/
int FNV64initBasis( FNV64context * const ctx,
                    const uint8_t basis[FNV64size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i&lt;FNV64size; ++i )
        ((uint8_t *)&amp;ctx-&gt;Hash)[i] = basis[i];
    ctx-&gt;Computed = FNVinited+FNV64state;
    return fnvSuccess;
}   /* end FNV64initBasis */

/* hash in a counted block  (64-bit)
 ******************************************************************/
int FNV64blockin( FNV64context * const ctx,
                   const void *vin,
                   long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV64state:
            ctx-&gt;Computed = FNVcomputed+FNV64state;
            break;
        case FNVcomputed+FNV64state:
            break;
        default:
            return fnvStateError;
    }
    for ( temp = ctx-&gt;Hash; length &gt; 0; length-- )
        temp = FNV64prime * ( temp ^ *in++ );
    ctx-&gt;Hash = temp;
    return fnvSuccess;
}   /* end FNV64blockin */

/* hash in a zero-terminated string not including the zero  (64-bit)
 ******************************************************************/
int FNV64stringin ( FNV64context * const ctx, const char *in ) {
    uint64_t        temp;
    uint8_t         ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV64state:
            ctx-&gt;Computed = FNVcomputed+FNV64state;
            break;
        case FNVcomputed+FNV64state:
            break;
        default:
             return fnvStateError;
    }
    temp = ctx-&gt;Hash;
    while ( (ch = (uint8_t)*in++) )
        temp = FNV64prime * ( temp ^ ch );
    ctx-&gt;Hash = temp;
    return fnvSuccess;
}   /* end FNV64stringin */

/* return hash as 64-bit int  (64-bit)
 ******************************************************************/
int FNV64INTresult ( FNV64context * const ctx,
                     uint64_t * const out ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV64state )
        return fnvStateError;
    ctx-&gt;Computed = FNVemptied+FNV64state;
    *out = ctx-&gt;Hash;
    ctx-&gt;Hash = 0;
    return fnvSuccess;
}   /* end FNV64INTresult */

/* return hash as 8-byte vector  (64-bit)
 ******************************************************************/
int FNV64result ( FNV64context * const ctx,
                 uint8_t out[FNV64size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV64state )
        return fnvStateError;
    ctx-&gt;Computed = FNVemptied+FNV64state;
    for ( int i=0; i&lt;FNV64size; ++i )
        out[i] = ((uint8_t *)&amp;ctx-&gt;Hash)[i];
    ctx-&gt;Hash = 0;
    return fnvSuccess;
}   /* end FNV64result */

/* hash the contents of a file, return 64-bit integer
 ******************************************************************/
int FNV64INTfile ( const char *fname,
                   uint64_t * const out ) {
    FNV64context e64Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV64init (&amp;e64Context)) )
        return error;
    if ( (error = FNV64filein (&amp;e64Context, fname)) )
        return error;
    return FNV64INTresult ( &amp;e64Context, out );
}   /* end FNV64INTfile */

/* hash the contents of a file, return 64-bit integer
 * with a non-standard basis
 ******************************************************************/
int FNV64INTfileBasis ( const char *fname,
                        uint64_t * const out,
                        uint64_t basis ) {
    FNV64context e64Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV64INTinitBasis (&amp;e64Context, basis)) )
        return error;
    if ( (error = FNV64filein (&amp;e64Context, fname)) )
        return error;
    return FNV64INTresult ( &amp;e64Context, out );
}   /* end FNV64INTfileBasis */

//***************************************************************
// END VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//***************************************************************
#else    /*  FNV_64bitIntegers */
//***************************************************************
// START VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//***************************************************************

/* 64-bit FNV_prime = 2^40 + 2^8 + 0xb3 */
/* #define FNV64prime 0x00000100000001B3 */
#define FNV64primeX 0x01B3
#define FNV64shift 8

/* FNV64: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV64string ( const char *in, uint8_t out[FNV64size] ) {
    FNV64context ctx;
    int error;

    if ( (error = FNV64init (&amp;ctx)) )
        return error;
    if ( (error = FNV64stringin (&amp;ctx, in)) )
        return error;
    return FNV64result (&amp;ctx, out);
}   /* end FNV64string */

/* FNV64: hash a zero-terminated string not including the zero
 * with a non-standard offset_basis
 ******************************************************************/
int FNV64stringBasis ( const char *in,
                  uint8_t out[FNV64size],
                  const uint8_t basis[FNV64size] ) {
    FNV64context ctx;
    int error;

    if ( (error = FNV64initBasis (&amp;ctx, basis)) )
        return error;
    if ( (error = FNV64stringin (&amp;ctx, in)) )
        return error;
    return FNV64result (&amp;ctx, out);
}   /* end FNV64stringBasis */

/* FNV64: hash a counted block
 ******************************************************************/
int FNV64block ( const void *vin,
                 long int length,
                 uint8_t out[FNV64size] ) {
    FNV64context ctx;
    int error;

    if ( (error = FNV64init (&amp;ctx)) )
        return error;
    if ( (error = FNV64blockin (&amp;ctx, vin, length)) )
        return error;
    return FNV64result (&amp;ctx, out);
}   /* end FNV64block */

/* FNV64: hash a counted block with a non-standard offset_basis
 ******************************************************************/
int FNV64blockBasis ( const void *vin,
                      long int length,
                      uint8_t out[FNV64size],
                      const uint8_t basis[FNV64size] ) {
    FNV64context ctx;
    int error;

    if ( (error = FNV64initBasis (&amp;ctx, basis)) )
        return error;
    if ( (error = FNV64blockin (&amp;ctx, vin, length)) )
        return error;
    return FNV64result (&amp;ctx, out);
}   /* end FNV64blockBasis */

//*****************************************************************
//        Set of init, input, and output functions below
//        to incrementally compute FNV64
//*****************************************************************

/* initialize context  (32-bit)
 ******************************************************************/
int FNV64init ( FNV64context * const ctx ) {
    if ( !ctx )
        return fnvNull;
    ctx-&gt;Hash[0] = 0xCBF2;
    ctx-&gt;Hash[1] = 0x9CE4;
    ctx-&gt;Hash[2] = 0x8422;
    ctx-&gt;Hash[3] = 0x2325;
    ctx-&gt;Computed = FNVinited+FNV64state;
    return fnvSuccess;
}   /* end FNV64init */

/* initialize context with a non-standard basis  (32-bit)
 ******************************************************************/
int FNV64initBasis ( FNV64context * const ctx,
                     const uint8_t basis[FNV64size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV64size/2; ++i ) {
        uint32_t temp = *basis++;
        ctx-&gt;Hash[i] = ( temp&lt;&lt;8 ) + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV64state;
    return fnvSuccess;
}   /* end FNV64initBasis */

/* hash in a counted block  (32-bit)
 ******************************************************************/
int FNV64blockin ( FNV64context * const ctx,
                   const void *vin,
                   long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp[FNV64size/2];
    uint32_t temp2[2];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV64state:
            ctx-&gt;Computed = FNVcomputed+FNV64state;
            break;
        case FNVcomputed+FNV64state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV64size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV64prime * ( temp ^ *in++ ); */
        temp[3] ^= *in++;
        temp2[1] = temp[3] &lt;&lt; FNV64shift;
        temp2[0] = temp[2] &lt;&lt; FNV64shift;
        for ( i=0; i&lt;4; ++i )
            temp[i] *= FNV64primeX;
        temp[1] += temp2[1];
        temp[0] += temp2[0];
        for ( i=2; i&gt;=0; --i ) {
            temp[i] += temp[i+1] &gt;&gt; 16;
            temp[i+1] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV64size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV64blockin */

/* hash in a zero-terminated string not including the zero  (32-bit)
 ******************************************************************/
int FNV64stringin ( FNV64context * const ctx, const char *in ) {
    uint32_t temp[FNV64size/2];
    uint32_t temp2[2];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV64state:
            ctx-&gt;Computed = FNVcomputed+FNV64state;
            break;
        case FNVcomputed+FNV64state:
            break;
        default:
             return fnvStateError;
    }
    for ( i=0; i&lt;FNV64size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];
    while ( ( ch = (uint8_t)*in++ ) ) {
        /* temp = FNV64prime * ( temp ^ ch ); */
        temp[3] ^= ch;
        temp2[1] = temp[3] &lt;&lt; FNV64shift;
        temp2[0] = temp[2] &lt;&lt; FNV64shift;
        for ( i=0; i&lt;4; ++i )
            temp[i] *= FNV64primeX;
        temp[1] += temp2[1];
        temp[0] += temp2[0];
        for ( i=2; i&gt;=0; --i ) {
            temp[i] += temp[i+1] &gt;&gt; 16;
            temp[i+1] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV64size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV64stringin */

/* return hash  (32-bit)
 ******************************************************************/
int FNV64result ( FNV64context * const ctx,
                  uint8_t out[FNV64size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV64state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV64size/2; ++i ) {
        out[2*i] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[2*i+1] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
        }
    ctx-&gt;Computed = FNVemptied+FNV64state;
    return fnvSuccess;
}   /* end FNV64result */

#endif    /*  FNV_64bitIntegers */
//*****************************************************************
// END VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//*****************************************************************

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.2-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-8.2.3">
          <h4 id="name-fnv128-code">
<a href="#section-8.2.3" class="section-number selfRef">8.2.3. </a><a href="#name-fnv128-code" class="section-name selfRef">FNV128 Code</a>
          </h4>
<p id="section-8.2.3-1">The following code is the header and C source for 128-bit FNV-1a providing a byte
vector hash.<a href="#section-8.2.3-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.3-2">
<pre>&lt;CODE BEGINS&gt; file "FNV128.h"

//************************** FNV128.h ************************//
//*************** See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV128_H_
#define _FNV128_H_

/*
 *  Description:
 *      This file provides headers for the 128-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV128size (128/8)

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint64_t    unsigned 64-bit integer (ifdef FNV_64bitIntegers)
 *  uint32_t    unsigned 32-bit integer
 *  uint16_t    unsigned 16-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV128 hash
 */
#ifdef FNV_64bitIntegers
    /* version if 64-bit integers supported */
typedef struct FNV128context_s {
        int Computed;  /* state */
        uint32_t Hash[FNV128size/4];
} FNV128context;

#else
    /* version if 64-bit integers NOT supported */
typedef struct FNV128context_s {
        int Computed;  /* state */
        uint16_t Hash[FNV128size/2];
} FNV128context;

#endif /* FNV_64bitIntegers */

/*  Function Prototypes:
 *
 *    FNV128string: hash a zero-terminated string not including
 *                  the terminating zero
 *    FNV128stringBasis: also takes an offset_basis parameter
 *
 *    FNV128block: hash a byte vector of a specified length
 *    FNV128blockBasis: also takes an offset_basis parameter
 *
 *    FNV128file: hash the contents of a file
 *    FNV128fileBasis: also takes an offset_basis parameter
 *
 *    FNV128init: initializes an FNV128 context
 *    FNV128initBasis: initializes an FNV128 context with a
 *                     provided 16-byte vector basis
 *    FNV128blockin: hash in a byte vector of a specified length
 *    FNV128stringin: hash in a zero-terminated string not
 *                    including the terminating zero
 *    FNV128filein: hash in the contents of a file
 *    FNV128result: returns the hash value
 *
 *    Hash is returned as an array of 8-bit unsigned integers
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV128 */
extern int FNV128string ( const char *in,
                          uint8_t out[FNV128size] );
extern int FNV128stringBasis ( const char *in,
                               uint8_t out[FNV128size],
                               const uint8_t basis[FNV128size] );
extern int FNV128block ( const void *vin,
                         long int length,
                         uint8_t out[FNV128size] );
extern int FNV128blockBasis ( const void *vin,
                              long int length,
                              uint8_t out[FNV128size],
                              const uint8_t basis[FNV128size] );
extern int FNV128file ( const char *fname,
                        uint8_t out[FNV128size] );
extern int FNV128fileBasis ( const char *fname,
                             uint8_t out[FNV128size],
                             const uint8_t basis[FNV128size] );
extern int FNV128init ( FNV128context * const );
extern int FNV128initBasis ( FNV128context * const,
                             const uint8_t basis[FNV128size] );
extern int FNV128blockin ( FNV128context * const,
                           const void *vin,
                           long int length );
extern int FNV128stringin ( FNV128context * const,
                            const char *in );
extern int FNV128filein ( FNV128context * const,
                         const char *fname );
extern int FNV128result ( FNV128context * const,
                          uint8_t out[FNV128size] );

#ifdef __cplusplus
}
#endif

#endif /* _FNV128_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.3-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.3-3">
<pre>&lt;CODE BEGINS&gt; file "FNV128.c"

//**************************** FNV128.c **************************//
//******************* See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This file implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 128-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "FNVconfig.h"
#include "fnv-private.h"
#include "FNV128.h"

//*****************************************************************
//  COMMON CODE FOR 64- AND 32-BIT INTEGER MODES
//*****************************************************************

/* FNV128: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV128string ( const char *in, uint8_t out[FNV128size] ) {
    FNV128context ctx;
    int error;

    if ( (error = FNV128init ( &amp;ctx )) )
        return error;
    if ( (error = FNV128stringin ( &amp;ctx, in )) )
        return error;
    return FNV128result (&amp;ctx, out);
}   /* end FNV128string */

/* FNV128: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV128stringBasis ( const char *in,
                        uint8_t out[FNV128size],
                        const uint8_t basis[FNV128size] ) {
    FNV128context ctx;
    int error;

    if ( (error = FNV128initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV128stringin ( &amp;ctx, in )) )
        return error;
    return FNV128result ( &amp;ctx, out );
}   /* end FNV128stringBasis */

/* FNV128: hash a counted block  (64/32-bit)
 ******************************************************************/
int FNV128block ( const void *vin,
                  long int length,
                  uint8_t out[FNV128size] ) {
    FNV128context ctx;
    int error;

    if ( (error = FNV128init ( &amp;ctx )) )
        return error;
    if ( (error = FNV128blockin ( &amp;ctx, vin, length )) )
        return error;
    return FNV128result ( &amp;ctx, out );
}   /* end FNV128block */

/* FNV128: hash a counted block  (64/32-bit)
 ******************************************************************/
int FNV128blockBasis ( const void *vin,
                       long int length,
                       uint8_t out[FNV128size],
                       const uint8_t basis[FNV128size] ) {
    FNV128context ctx;
    int error;

    if ( (error = FNV128initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV128blockin ( &amp;ctx, vin, length )) )
        return error;
    return FNV128result ( &amp;ctx, out );
}   /* end FNV128blockBasis */

/* hash the contents of a file
 ******************************************************************/
int FNV128file ( const char *fname,
                 uint8_t out[FNV128size] ) {
    FNV128context e128Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV128init (&amp;e128Context)) )
        return error;
    if ( (error = FNV128filein (&amp;e128Context, fname)) )
        return error;
    return FNV128result ( &amp;e128Context, out );
}   /* end FNV128file */

/* hash the contents of a file with a non-standard basis
 ******************************************************************/
int FNV128fileBasis ( const char *fname,
                      uint8_t out[FNV128size],
                      const uint8_t basis[FNV128size] ) {
    FNV128context e128Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV128initBasis (&amp;e128Context, basis)) )
        return error;
    if ( (error = FNV128filein (&amp;e128Context, fname)) )
        return error;
    return FNV128result ( &amp;e128Context, out );
}   /* end FNV128fileBasis */

/* hash in the contents of a file
 ******************************************************************/
int FNV128filein ( FNV128context * const e128Context,
                   const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e128Context || !fname )
        return fnvNull;
    switch ( e128Context-&gt;Computed ) {
        case FNVinited+FNV128state:
            e128Context-&gt;Computed = FNVcomputed+FNV128state;
            break;
        case FNVcomputed+FNV128state:
            break;
        default:
            return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV128blockin ( e128Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error = FNV128blockin ( e128Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error) return fnvBadParam;
    return fnvSuccess;
}   /* end FNV128filein */

//*****************************************************************
// START VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//*****************************************************************
#ifdef FNV_64bitIntegers

/* 128-bit FNV_prime = 2^88 + 2^8 + 0x3b */
/* 0x00000000 01000000 00000000 0000013B */
#define FNV128primeX 0x013B
#define FNV128shift 24

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV128
//*****************************************************************/

/* initialize context  (64-bit)
 ******************************************************************/
int FNV128init ( FNV128context * const ctx ) {
    const uint32_t FNV128basis[FNV128size/4] =
        { 0x6C62272E, 0x07BB0142, 0x62B82175, 0x6295C58D };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;4; ++i )
        ctx-&gt;Hash[i] = FNV128basis[i];
    ctx-&gt;Computed = FNVinited+FNV128state;
    return fnvSuccess;
}   /* end FNV128init */

/* initialize context with a provided 16-byte vector basis  (64-bit)
 ******************************************************************/
int FNV128initBasis ( FNV128context * const ctx,
                      const uint8_t basis[FNV128size] ) {
   if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV128size/4; ++i ) {
        uint32_t temp = *basis++&lt;&lt;24;
        temp += *basis++&lt;&lt;16;
        temp += *basis++&lt;&lt;8;
        ctx-&gt;Hash[i] = temp + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV128state;
    return fnvSuccess;
}   /* end FNV128initBasis */

/* hash in a counted block  (64-bit)
 ******************************************************************/
int FNV128blockin ( FNV128context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp[FNV128size/4];
    uint64_t temp2[2];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV128state:
            ctx-&gt;Computed = FNVcomputed+FNV128state;
            break;
        case FNVcomputed+FNV128state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV128size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV128prime * ( temp ^ *in++ ); */
        temp[FNV128size/4-1] ^= *in++;
        temp2[1] = temp[3] &lt;&lt; FNV128shift;
        temp2[0] = temp[2] &lt;&lt; FNV128shift;
        for ( i=0; i &lt; FNV128size/4; ++i )
            temp[i] *= FNV128primeX;
        temp[1] += temp2[1];
        temp[0] += temp2[0];
        for ( i = 3; i &gt; 0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV128size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];
    return fnvSuccess;
}   /* end FNV128blockin */

/* hash in a zero-terminated string not including the zero  (64-bit)
 ******************************************************************/
int FNV128stringin ( FNV128context * const ctx, const char *in ) {
    uint64_t temp[FNV128size/4];
    uint64_t temp2[2];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV128state:
            ctx-&gt;Computed = FNVcomputed+FNV128state;
            break;
        case FNVcomputed+FNV128state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV128size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];
    while ( ( ch = (uint8_t)*in++ ) ) {
        /* temp = FNV128prime * ( temp ^ ch ); */
        temp[3] ^= ch;
        temp2[1] = temp[3] &lt;&lt; FNV128shift;
        temp2[0] = temp[2] &lt;&lt; FNV128shift;
        for ( i=0; i &lt; FNV128size/4; ++i )
            temp[i] *= FNV128primeX;
        temp[1] += temp2[1];
        temp[0] += temp2[0];
        for ( i = 3; i &gt; 0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV128size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];
    return fnvSuccess;
}   /* end FNV128stringin */

/* return hash as 16-byte vector  (64-bit)
 ******************************************************************/
int FNV128result ( FNV128context * const ctx,
                   uint8_t out[FNV128size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV128state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV128size/4; ++i ) {
        out[4*i] = ctx-&gt;Hash[i] &gt;&gt; 24;
        out[4*i+1] = ctx-&gt;Hash[i] &gt;&gt; 16;
        out[4*i+2] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[4*i+3] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV128state;
    return fnvSuccess;
}   /* end FNV128result */

//****************************************************************
// END VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//****************************************************************
#else    /*  FNV_64bitIntegers */
//****************************************************************
// START VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//****************************************************************

/* 128-bit FNV_prime = 2^88 + 2^8 + 0x3b */
/* 0x00000000 01000000 00000000 0000013B */
#define FNV128primeX 0x013B
#define FNV128shift 8

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV128
//*****************************************************************

/* initialize context  (32-bit)
 ******************************************************************/
int FNV128init ( FNV128context * const ctx ) {
    const uint16_t FNV128basis[FNV128size/2] =
             { 0x6C62, 0x272E, 0x07BB, 0x0142,
               0x62B8, 0x2175, 0x6295, 0xC58D };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV128size/2; ++i )
        ctx-&gt;Hash[i] = FNV128basis[i];
    ctx-&gt;Computed = FNVinited+FNV128state;
    return fnvSuccess;
}   /* end FNV128init */

/* initialize context with a provided 16-byte vector basis  (32-bit)
 ******************************************************************/
int FNV128initBasis ( FNV128context * const ctx,
                      const uint8_t basis[FNV128size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV128size/2; ++i ) {
        uint32_t temp = *basis++;
        ctx-&gt;Hash[i] = ( temp&lt;&lt;8 ) + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV128state;
    return fnvSuccess;
}   /* end FNV128initBasis */

/* hash in a counted block  (32-bit)
 *****************************************************************/
int FNV128blockin ( FNV128context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp[FNV128size/2];
    uint32_t temp2[3];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV128state:
            ctx-&gt;Computed = FNVcomputed+FNV128state;
            break;
        case FNVcomputed+FNV128state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i &lt; FNV128size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV128prime * ( temp ^ *in++ ); */
        temp[FNV128size/2-1] ^= *in++;
        for ( i=2; i &gt;= 0; --i )
            temp2[i] = temp[i+5] &lt;&lt; FNV128shift;
        for ( i=0; i &lt; (FNV128size/2); ++i )
            temp[i] *= FNV128primeX;
        for ( i=2; i &gt;= 0; --i )
            temp[i] += temp2[i];
        for ( i=FNV128size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16;
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i &lt; FNV128size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV128blockin */

/* hash in a zero-terminated string not including the zero  (32-bit)
 ******************************************************************/
int FNV128stringin ( FNV128context * const ctx, const char *in ) {
    uint32_t temp[FNV128size/2];
    uint32_t temp2[3];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV128state:
            ctx-&gt;Computed = FNVcomputed+FNV128state;
            break;
        case FNVcomputed+FNV128state:
            break;
        default:
             return fnvStateError;
    }
    for ( i=0; i &lt; FNV128size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV128prime * ( temp ^ *in++ ); */
        temp[FNV128size/2-1] ^= ch;
        for ( i=2; i &gt;= 0; --i )
            temp2[i] = temp[i+5] &lt;&lt; FNV128shift;
        for ( i=0; i&lt;(FNV128size/2); ++i )
            temp[i] *= FNV128primeX;
        for ( i=2; i &gt;= 0; --i )
            temp[i] += temp2[i];
        for ( i=FNV128size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16;
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i &lt; FNV128size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV128stringin */

/* return hash  (32-bit)
 ******************************************************************/
int FNV128result ( FNV128context * const ctx,
                   uint8_t out[FNV128size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV128state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV128size/2; ++i ) {
        out[2*i] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[2*i+1] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV128state;
    return fnvSuccess;
}   /* end FNV128result */

#endif    /*  FNV_64bitIntegers */
//******************************************************************
// END VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//******************************************************************

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.3-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-8.2.4">
          <h4 id="name-fnv256-code">
<a href="#section-8.2.4" class="section-number selfRef">8.2.4. </a><a href="#name-fnv256-code" class="section-name selfRef">FNV256 Code</a>
          </h4>
<p id="section-8.2.4-1">The following code is the header and C source for 256-bit FNV-1a providing a byte
vector hash.<a href="#section-8.2.4-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.4-2">
<pre>&lt;CODE BEGINS&gt; file "FNV256.h"

//************************* FNV256.h ***********************//
//************** See RFC 9923 for details. *****************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV256_H_
#define _FNV256_H_

/*
 *  Description:
 *      This file provides headers for the 256-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV256size (256/8)

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint64_t    unsigned 64-bit integer (ifdef FNV_64bitIntegers)
 *  uint32_t    unsigned 32-bit integer
 *  uint16_t    unsigned 16-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV256 hash
 */
#ifdef FNV_64bitIntegers
    /* version if 64-bit integers supported */
typedef struct FNV256context_s {
        int Computed;  /* state */
        uint32_t Hash[FNV256size/4];
} FNV256context;

#else
    /* version if 64-bit integers NOT supported */
typedef struct FNV256context_s {
        int Computed;  /* state */
        uint16_t Hash[FNV256size/2];
} FNV256context;

#endif /* FNV_64bitIntegers */

/*  Function Prototypes:
 *
 *    FNV256string: hash a zero-terminated string not including
 *                  the terminating zero
 *    FNV256stringBasis: also takes an offset_basis parameter
 *
 *    FNV256block: hash a byte vector of a specified length
 *    FNV256blockBasis: also takes an offset_basis parameter
 *
 *    FNV256file: hash the contents of a file
 *    FNV256fileBasis: also takes an offset_basis parameter
 *
 *    FNV256init: initializes an FNV256 context
 *    FNV256initBasis: initializes an FNV256 context with a
 *                     provided 32-byte vector basis
 *    FNV256blockin: hash in a byte vector of a specified length
 *    FNV256stringin: hash in a zero-terminated string not
 *                    including the terminating zero
 *    FNV256filein: hash in the contents of a file
 *    FNV256result: returns the hash value
 *
 *    Hash is returned as an array of 8-bit unsigned integers
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV256 */
extern int FNV256string ( const char *in,
                          uint8_t out[FNV256size] );
extern int FNV256stringBasis ( const char *in,
                               uint8_t out[FNV256size],
                               const uint8_t basis[FNV256size] );
extern int FNV256block ( const void *vin,
                         long int length,
                         uint8_t out[FNV256size] );
extern int FNV256blockBasis ( const void *vin,
                              long int length,
                              uint8_t out[FNV256size],
                              const uint8_t basis[FNV256size] );
extern int FNV256file ( const char *fname,
                        uint8_t out[FNV256size] );
extern int FNV256fileBasis ( const char *fname,
                             uint8_t out[FNV256size],
                             const uint8_t basis[FNV256size] );
extern int FNV256init ( FNV256context * const );
extern int FNV256initBasis ( FNV256context * const,
                             const uint8_t basis[FNV256size] );
extern int FNV256blockin ( FNV256context * const,
                           const void *vin,
                           long int length );
extern int FNV256stringin ( FNV256context * const,
                            const char *in );
extern int FNV256filein ( FNV256context * const,
                         const char *fname );
extern int FNV256result ( FNV256context * const,
                          uint8_t out[FNV256size] );

#ifdef __cplusplus
}
#endif

#endif /* _FNV256_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.4-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.4-3">
<pre>&lt;CODE BEGINS&gt; file "FNV256.c"

//**************************** FNV256.c **************************//
//******************* See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This file implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 256-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "fnv-private.h"
#include "FNV256.h"

//*****************************************************************
//  COMMON CODE FOR 64- AND 32-BIT INTEGER MODES
//*****************************************************************

/* FNV256: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV256string ( const char *in, uint8_t out[FNV256size] ) {
    FNV256context ctx;
    int error;

    if ( (error = FNV256init ( &amp;ctx )) )
        return error;
    if ( (error = FNV256stringin ( &amp;ctx, in )) )
        return error;
    return FNV256result ( &amp;ctx, out );
}   /* end FNV256string */

/* FNV256: hash a zero-terminated string not including the zero
 * with a non-standard basis
 ******************************************************************/
int FNV256stringBasis ( const char *in,
                        uint8_t out[FNV256size],
                        const uint8_t basis[FNV256size] ) {
    FNV256context ctx;
    int error;

    if ( (error = FNV256initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV256stringin ( &amp;ctx, in )) )
        return error;
    return FNV256result ( &amp;ctx, out );
}   /* end FNV256stringBasis */

/* FNV256: hash a counted block  (64/32-bit)
 ******************************************************************/
int FNV256block ( const void *vin,
                  long int length,
                  uint8_t out[FNV256size] ) {
    FNV256context ctx;
    int error;

    if ( (error = FNV256init ( &amp;ctx )) )
        return error;
    if ( (error = FNV256blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV256result ( &amp;ctx, out );
}   /* end FNV256block */

/* FNV256: hash a counted block  (64/32-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV256blockBasis ( const void *vin,
                       long int length,
                       uint8_t out[FNV256size],
                       const uint8_t basis[FNV256size] ) {
    FNV256context ctx;
    int error;

    if ( (error = FNV256initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV256blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV256result ( &amp;ctx, out );
}   /* end FNV256blockBasis */

/* hash the contents of a file
 ******************************************************************/
int FNV256file ( const char *fname,
                        uint8_t out[FNV256size] ) {
    FNV256context e256Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV256init (&amp;e256Context)) )
        return error;
    if ( (error = FNV256filein (&amp;e256Context, fname)) )
        return error;
    return FNV256result ( &amp;e256Context, out );
}   /* end FNV256file */

/* hash the contents of a file with a non-standard basis
 ******************************************************************/
int FNV256fileBasis ( const char *fname,
                      uint8_t out[FNV256size],
                      const uint8_t basis[FNV256size]) {
    FNV256context e256Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV256initBasis (&amp;e256Context, basis)) )
        return error;
    if ( (error = FNV256filein (&amp;e256Context, fname)) )
        return error;
    return FNV256result ( &amp;e256Context, out );
}   /* end FNV256fileBasis */

/* hash in the contents of a file
 ******************************************************************/
int FNV256filein ( FNV256context * const e256Context,
                   const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e256Context || !fname )
        return fnvNull;
    switch ( e256Context-&gt;Computed ) {
        case FNVinited+FNV256state:
            e256Context-&gt;Computed = FNVcomputed+FNV256state;
            break;
        case FNVcomputed+FNV256state:
            break;
        default:
             return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV256blockin ( e256Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error = FNV256blockin ( e256Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error) return fnvBadParam;
    return fnvSuccess;
}   /* end FNV256filein */

//*****************************************************************
// START VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//*****************************************************************
#ifdef FNV_64bitIntegers

/* 256-bit FNV_prime = 2^168 + 2^8 + 0x63 */
/* 0x0000000000000000 0000010000000000
     0000000000000000 0000000000000163 */
#define FNV256primeX 0x0163
#define FNV256shift 8

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV256
//*****************************************************************

/* initialize context  (64-bit)
 ******************************************************************/
int FNV256init ( FNV256context * const ctx ) {
    const uint32_t FNV256basis[FNV256size/4] = {
             0xDD268DBC, 0xAAC55036, 0x2D98C384, 0xC4E576CC,
             0xC8B15368, 0x47B6BBB3, 0x1023B4C8, 0xCAEE0535 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV256size/4; ++i )
        ctx-&gt;Hash[i] = FNV256basis[i];
    ctx-&gt;Computed = FNVinited+FNV256state;
    return fnvSuccess;
}   /* end FNV256init */

/* initialize context with a provided 32-byte vector basis  (64-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV256initBasis ( FNV256context * const ctx,
                      const uint8_t basis[FNV256size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV256size/4; ++i ) {
        uint32_t temp = *basis++&lt;&lt;24;
        temp += *basis++&lt;&lt;16;
        temp += *basis++&lt;&lt;8;
        ctx-&gt;Hash[i] = temp + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV256state;
    return fnvSuccess;
}   /* end FNV256initBasis */

/* hash in a counted block  (64-bit)
 ******************************************************************/
int FNV256blockin ( FNV256context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp[FNV256size/4];
    uint64_t temp2[3];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV256state:
            ctx-&gt;Computed = FNVcomputed+FNV256state;
            break;
        case FNVcomputed+FNV256state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV256size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV256prime * ( temp ^ *in++ ); */
        temp[FNV256size/4-1] ^= *in++;
        for ( i=2; i &gt;= 0; --i )
            temp2[i] = temp[i+5] &lt;&lt; FNV256shift;
        for ( i=0; i &lt; FNV256size/4; ++i )
            temp[i] *= FNV256primeX;
        for ( i=2; i &gt;= 0; --i )
            temp[i] += temp2[i];
        for ( i=FNV256size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV256size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];
    return fnvSuccess;
}   /* end FNV256blockin */

/* hash in a zero-terminated string not including the zero  (64-bit)
 ******************************************************************/
int FNV256stringin ( FNV256context * const ctx, const char *in ) {
    uint64_t temp[FNV256size/4];
    uint64_t temp2[3];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV256state:
            ctx-&gt;Computed = FNVcomputed+FNV256state;
            break;
        case FNVcomputed+FNV256state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV256size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV256prime * ( temp ^ ch ); */
        temp[FNV256size/4-1] ^= ch;
        for ( i=2; i &gt;= 0; --i )
            temp2[i] = temp[i+5] &lt;&lt; FNV256shift;
        for ( i=0; i&lt;FNV256size/4; ++i )
            temp[i] *= FNV256primeX;
        for ( i=2; i &gt;= 0; --i )
            temp[i] += temp2[i];
        for ( i=FNV256size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV256size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];
    return fnvSuccess;
}   /* end FNV256stringin */

/* return hash as 8-byte vector  (64-bit)
 ******************************************************************/
int FNV256result ( FNV256context * const ctx,
                   uint8_t out[FNV256size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV256state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV256size/4; ++i ) {
        out[4*i] = ctx-&gt;Hash[i] &gt;&gt; 24;
        out[4*i+1] = ctx-&gt;Hash[i] &gt;&gt; 16;
        out[4*i+2] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[4*i+3] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV256state;
    return fnvSuccess;
}   /* end FNV256result */

//****************************************************************
// END VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//****************************************************************
#else    /*  FNV_64bitIntegers */
//****************************************************************
// START VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//****************************************************************

/* 256-bit FNV_prime = 2^168 + 2^8 + 0x63 */
/* 0x00000000 00000000 00000100 00000000
     00000000 00000000 00000000 00000163 */
#define FNV256primeX 0x0163
#define FNV256shift 8

//****************************************************************
//       Set of init, input, and output functions below
//       to incrementally compute FNV256
//****************************************************************

/* initialize context  (32-bit)
 *****************************************************************/
int FNV256init ( FNV256context * const ctx ) {
    const uint16_t FNV256basis[FNV256size/2] = {
0xDD26, 0x8DBC, 0xAAC5, 0x5036, 0x2D98, 0xC384, 0xC4E5, 0x76CC,
0xC8B1, 0x5368, 0x47B6, 0xBBB3, 0x1023, 0xB4C8, 0xCAEE, 0x0535 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV256size/2; ++i )
        ctx-&gt;Hash[i] = FNV256basis[i];
    ctx-&gt;Computed = FNVinited+FNV256state;
    return fnvSuccess;
}   /* end FNV256init */

/* initialize context with a provided 32-byte vector basis  (32-bit)
 ******************************************************************/
int FNV256initBasis ( FNV256context * const ctx,
                      const uint8_t basis[FNV256size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV256size/2; ++i ) {
        uint32_t temp = *basis++;
        ctx-&gt;Hash[i] = ( temp&lt;&lt;8 ) + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV256state;
    return fnvSuccess;
}   /* end FNV256initBasis */

/* hash in a counted block  (32-bit)
 *****************************************************************/
int FNV256blockin ( FNV256context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp[FNV256size/2];
    uint32_t temp2[6];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV256state:
            ctx-&gt;Computed = FNVcomputed+FNV256state;
            break;
        case FNVcomputed+FNV256state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV256size/2; ++i )
        temp[i] = ctx-&gt;Hash[i];
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV256prime * ( temp ^ *in++ ); */
        temp[FNV256size/2-1] ^= *in++;
        for ( i=0; i&lt;6; ++i )
            temp2[5-i] = temp[FNV256size/2-1-i] &lt;&lt; FNV256shift;
        for ( i=0; i&lt;FNV256size/2; ++i )
            temp[i] *= FNV256primeX;
        for ( i=0; i&lt;6; ++i )
            temp[i] += temp2[i];
        for ( i=FNV256size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16;
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV256size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV256blockin */

/* hash in a zero-terminated string not including the zero  (32-bit)
 ******************************************************************/
int FNV256stringin ( FNV256context * const ctx, const char *in ) {
    uint32_t temp[FNV256size/2];
    uint32_t temp2[6];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV256state:
            ctx-&gt;Computed = FNVcomputed+FNV256state;
            break;
        case FNVcomputed+FNV256state:
            break;
        default:
             return fnvStateError;
    }
    for ( i=0; i&lt;FNV256size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];
    while ( ( ch = (uint8_t)*in++ ) ) {
        /* temp = FNV256prime * ( temp ^ *in++ ); */
        temp[FNV256size/2-1] ^= ch;
        for ( i=0; i&lt;6; ++i )
            temp2[5-i] = temp[FNV256size/2-1-i] &lt;&lt; FNV256shift;
        for ( i=0; i&lt;FNV256size/2; ++i )
            temp[i] *= FNV256primeX;
        for ( i=0; i&lt;6; ++i )
            temp[i] += temp2[i];
        for ( i=FNV256size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16;
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV256size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];
    return fnvSuccess;
}   /* end FNV256stringin */

/* return hash  (32-bit)
 *****************************************************************/
int FNV256result ( FNV256context * const ctx,
                   uint8_t out[FNV256size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV256state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV256size/2; ++i ) {
        out[2*i] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[2*i+1] = ctx-&gt;Hash[i];
        ctx-&gt;Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV256state;
    return fnvSuccess;
}   /* end FNV256result */

#endif    /*  FNV_64bitIntegers */
//****************************************************************
// END VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//****************************************************************

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.4-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-8.2.5">
          <h4 id="name-fnv512-code">
<a href="#section-8.2.5" class="section-number selfRef">8.2.5. </a><a href="#name-fnv512-code" class="section-name selfRef">FNV512 Code</a>
          </h4>
<p id="section-8.2.5-1">The following code is the header and C source for 512-bit FNV-1a providing a byte
vector hash.<a href="#section-8.2.5-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.5-2">
<pre>&lt;CODE BEGINS&gt; file "FNV512.h"

//************************* FNV512.h ***********************//
//************** See RFC 9923 for details. *****************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV512_H_
#define _FNV512_H_

/*
 *  Description:
 *      This file provides headers for the 512-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV512size (512/8)

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint64_t    unsigned 64-bit integer (ifdef FNV_64bitIntegers)
 *  uint32_t    unsigned 32-bit integer
 *  uint16_t    unsigned 16-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV512 hash
 */
#ifdef FNV_64bitIntegers
    /* version if 64-bit integers supported */
typedef struct FNV512context_s {
        int Computed;  /* state */
        uint32_t Hash[FNV512size/4];
} FNV512context;

#else
    /* version if 64-bit integers NOT supported */
typedef struct FNV512context_s {
        int Computed;  /* state */
        uint16_t Hash[FNV512size/2];
} FNV512context;

#endif /* FNV_64bitIntegers */

/*  Function Prototypes:
 *
 *    FNV512string: hash a zero-terminated string not including
 *                  the terminating zero
 *    FNV512stringBasis: also takes an offset_basis parameter
 *
 *    FNV512block: hash a byte vector of a specified length
 *    FNV512blockBasis: also takes an offset_basis parameter
 *
 *    FNV512file: hash the contents of a file
 *    FNV512fileBasis: also takes an offset_basis parameter
 *
 *    FNV512init: initializes an FNV512 context
 *    FNV512initBasis: initializes an FNV512 context with a
 *                     provided 64-byte vector basis
 *    FNV512blockin: hash in a byte vector of a specified length
 *    FNV512stringin: hash in a zero-terminated string not
 *                    including the terminating zero
 *    FNV512filein: hash in the contents of a file
 *    FNV512result: returns the hash value
 *
 *    Hash is returned as an array of 8-bit unsigned integers
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV512 */
extern int FNV512string ( const char *in,
                          uint8_t out[FNV512size] );
extern int FNV512stringBasis ( const char *in,
                               uint8_t out[FNV512size],
                               const uint8_t basis[FNV512size] );
extern int FNV512block ( const void *vin,
                         long int length,
                         uint8_t out[FNV512size] );
extern int FNV512blockBasis ( const void *vin,
                              long int length,
                              uint8_t out[FNV512size],
                              const uint8_t basis[FNV512size] );
extern int FNV512file ( const char *fname,
                        uint8_t out[FNV512size] );
extern int FNV512fileBasis ( const char *fname,
                             uint8_t out[FNV512size],
                             const uint8_t basis[FNV512size] );
extern int FNV512init ( FNV512context * const );
extern int FNV512initBasis ( FNV512context * const,
                             const uint8_t basis[FNV512size] );
extern int FNV512blockin ( FNV512context * const,
                           const void *vin,
                           long int length );
extern int FNV512stringin ( FNV512context * const,
                            const char *in );
extern int FNV512filein ( FNV512context * const,
                          const char *fname );
extern int FNV512result ( FNV512context * const,
                          uint8_t out[FNV512size] );

#ifdef __cplusplus
}
#endif

#endif /* _FNV512_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.5-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.5-3">
<pre>&lt;CODE BEGINS&gt; file "FNV512.c"

//**************************** FNV512.c **************************//
//******************* See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This file implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 512-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "fnv-private.h"
#include "FNV512.h"

//*****************************************************************
//  COMMON CODE FOR 64- AND 32-BIT INTEGER MODES
//*****************************************************************

/* FNV512: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV512string ( const char *in, uint8_t out[FNV512size] ) {
    FNV512context ctx;
    int error;

    if ( (error = FNV512init ( &amp;ctx )) )
        return error;
    if ( (error = FNV512stringin ( &amp;ctx, in )) )
        return error;
    return FNV512result ( &amp;ctx, out );
}   /* end FNV512string */

/* FNV512: hash a zero-terminated string not including the zero
 * with a non-standard basis
 ******************************************************************/
int FNV512stringBasis ( const char *in,
                        uint8_t out[FNV512size],
                        const uint8_t basis[FNV512size] ) {
    FNV512context ctx;
    int error;

    if ( (error = FNV512initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV512stringin ( &amp;ctx, in )) )
        return error;
    return FNV512result ( &amp;ctx, out );
}   /* end FNV512stringBasis */

/* FNV512: hash a counted block  (64/32-bit)
 ******************************************************************/
int FNV512block ( const void *vin,
                  long int length,
                  uint8_t out[FNV512size] ) {
    FNV512context ctx;
    int error;

    if ( (error = FNV512init ( &amp;ctx )) )
        return error;
    if ( (error = FNV512blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV512result ( &amp;ctx, out );
}   /* end FNV512block */

/* FNV512: hash a counted block  (64/32-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV512blockBasis ( const void *vin,
                       long int length,
                       uint8_t out[FNV512size],
                       const uint8_t basis[FNV512size] ) {
    FNV512context ctx;
    int error;

    if ( (error = FNV512initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV512blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV512result ( &amp;ctx, out );
}   /* end FNV512blockBasis */

/* hash the contents of a file
 ******************************************************************/
int FNV512file ( const char *fname,
                 uint8_t out[FNV512size] ) {
    FNV512context e512Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV512init (&amp;e512Context)) )
        return error;
    if ( (error = FNV512filein (&amp;e512Context, fname)) )
        return error;
    return FNV512result ( &amp;e512Context, out );
}   /* end FNV512file */

/* hash the contents of a file with a non-standard basis
 ******************************************************************/
int FNV512fileBasis ( const char *fname,
                      uint8_t out[FNV512size],
                      const uint8_t basis[FNV512size] ) {
    FNV512context e512Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV512initBasis (&amp;e512Context, basis)) )
        return error;
    if ( (error = FNV512filein (&amp;e512Context, fname)) )
        return error;
    return FNV512result ( &amp;e512Context, out );
}   /* end FNV512fileBasis */

/* hash in the contents of a file
 ******************************************************************/
int FNV512filein ( FNV512context * const e512Context,
                    const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e512Context || !fname )
        return fnvNull;
    switch ( e512Context-&gt;Computed ) {
        case FNVinited+FNV512state:
            e512Context-&gt;Computed = FNVcomputed+FNV512state;
            break;
        case FNVcomputed+FNV512state:
            break;
        default:
             return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV512blockin ( e512Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error=FNV512blockin ( e512Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error) return fnvBadParam;
    return fnvSuccess;
}   /* end FNV512filein */

//*****************************************************************
// START VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//*****************************************************************
#ifdef FNV_64bitIntegers

/* 512-bit FNV_prime = 2^344 + 2^8 + 0x57 =
   0x0000000000000000 0000000000000000
     0000000001000000 0000000000000000
     0000000000000000 0000000000000000
     0000000000000000 0000000000000157 */
#define FNV512primeX 0x0157
#define FNV512shift 24

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV512
//*****************************************************************

/* initialize context  (64-bit)
 ******************************************************************/
int FNV512init ( FNV512context * const ctx ) {
    const uint32_t FNV512basis[FNV512size/4] = {
         0xB86DB0B1, 0x171F4416, 0xDCA1E50F, 0x309990AC,
         0xAC87D059, 0xC9000000, 0x00000000, 0x00000D21,
         0xE948F68A, 0x34C192F6, 0x2EA79BC9, 0x42DBE7CE,
         0x18203641, 0x5F56E34B, 0xAC982AAC, 0x4AFE9FD9 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV512size/4; ++i )
        ctx-&gt;Hash[i] = FNV512basis[i];
    ctx-&gt;Computed = FNVinited+FNV512state;
    return fnvSuccess;
}   /* end FNV512init */

/* initialize context with a provided 64-byte vector basis  (64-bit)
 ******************************************************************/
int FNV512initBasis ( FNV512context * const ctx,
                      const uint8_t basis[FNV512size] ) {
     if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV512size/4; ++i ) {
        uint32_t temp = *basis++&lt;&lt;24;
        temp += *basis++&lt;&lt;16;
        temp += *basis++&lt;&lt;8;
        ctx-&gt;Hash[i] = temp + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV512state;
    return fnvSuccess;
}   /* end FNV512initBasis */

/* hash in a counted block  (64-bit)
 ******************************************************************/
int FNV512blockin ( FNV512context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp[FNV512size/4];
    uint64_t temp2[6];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV512state:
            ctx-&gt;Computed = FNVcomputed+FNV512state;
            break;
        case FNVcomputed+FNV512state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV512size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV512prime * ( temp ^ *in++ ); */
        temp[FNV512size/4-1] ^= *in++;
        for ( i=0; i&lt;6; ++i )
            temp2[5-i] = temp[FNV512size/4-1-i] &lt;&lt; FNV512shift;
        for ( i=0; i&lt;FNV512size/4; ++i )
            temp[i] *= FNV512primeX;
        for ( i=0; i&lt;6; ++i )
            temp[i] += temp2[i];
        for ( i=FNV512size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32; // propagate carries
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }   /* end for length */
    for ( i=0; i&lt;FNV512size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV512blockin */

/* hash in a zero-terminated string not including the zero  (64-bit)
 ******************************************************************/
int FNV512stringin ( FNV512context * const ctx, const char *in ) {
    uint64_t temp[FNV512size/4];
    uint64_t temp2[6];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV512state:
            ctx-&gt;Computed = FNVcomputed+FNV512state;
            break;
        case FNVcomputed+FNV512state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV512size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV512prime * ( temp ^ ch ); */
        temp[FNV512size/4-1] ^= ch;
        for ( i=0; i&lt;6; ++i )
            temp2[5-i] = temp[FNV512size/4-1-i] &lt;&lt; FNV512shift;
        for ( i=0; i&lt;FNV512size/4; ++i )
            temp[i] *= FNV512primeX;
        for ( i=0; i&lt;6; ++i )
            temp[i] += temp2[i];
        for ( i=FNV512size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32; // propagate carries
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV512size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV512stringin */

/* return hash  (64-bit)
 ******************************************************************/
int FNV512result ( FNV512context * const ctx,
                   uint8_t out[FNV512size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV512state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV512size/4; ++i ) {
        out[4*i] = ctx-&gt;Hash[i] &gt;&gt; 24;
        out[4*i+1] = ctx-&gt;Hash[i] &gt;&gt; 16;
        out[4*i+2] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[4*i+3] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV512state;
    return fnvSuccess;
}   /* end FNV512result */

//*****************************************************************
// END VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//*****************************************************************
#else    /*  FNV_64bitIntegers */
//*****************************************************************
// START VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//*****************************************************************

/* 512-bit FNV_prime = 2^344 + 2^8 + 0x57 =
   0x00000000 00000000 00000000 00000000
     00000000 01000000 00000000 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000000 00000157 */
#define FNV512primeX 0x0157
#define FNV512shift 8

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV512
//*****************************************************************

/* initialize context  (32-bit)
 ******************************************************************/
int FNV512init ( FNV512context * const ctx ) {
    const uint16_t FNV512basis[FNV512size/2] = {
0xB86D, 0xB0B1, 0x171F, 0x4416, 0xDCA1, 0xE50F, 0x3099, 0x90AC,
0xAC87, 0xD059, 0xC900, 0x0000, 0x0000, 0x0000, 0x0000, 0x0D21,
0xE948, 0xF68A, 0x34C1, 0x92F6, 0x2EA7, 0x9BC9, 0x42DB, 0xE7CE,
0x1820, 0x3641, 0x5F56, 0xE34B, 0xAC98, 0x2AAC, 0x4AFE, 0x9FD9 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV512size/2; ++i )
        ctx-&gt;Hash[i] = FNV512basis[i];
    ctx-&gt;Computed = FNVinited+FNV512state;
    return fnvSuccess;
}   /* end FNV512init */

/* initialize context with a provided 64-byte vector basis  (32-bit)
 ******************************************************************/
int FNV512initBasis ( FNV512context * const ctx,
                      const uint8_t basis[FNV512size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV512size/2; ++i ) {
        uint32_t temp = *basis++;
        ctx-&gt;Hash[i] = ( temp&lt;&lt;8 ) + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV512state;
    return fnvSuccess;
}   /* end FNV512initBasis */

/* hash in a counted block  (32-bit)
 ******************************************************************/
int FNV512blockin ( FNV512context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp[FNV512size/2];
    uint32_t temp2[11];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
   switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV512state:
            ctx-&gt;Computed = FNVcomputed+FNV512state;
            break;
        case FNVcomputed+FNV512state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV512size/2; ++i )
        temp[i] = ctx-&gt;Hash[i];  // copy into temp
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV512prime * ( temp ^ *in++ ); */
        temp[FNV512size/2-1] ^= *in++;
        for ( i=0; i&lt;11; ++i )
            temp2[10-i] = temp[FNV512size/2-1-i] &lt;&lt; FNV512shift;
        for ( i=0; i&lt;FNV512size/2; ++i )
            temp[i] *= FNV512primeX;
        for ( i=0; i&lt;11; ++i )
            temp[i] += temp2[i];
        for ( i=FNV512size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16; // propagate carries
            temp[i] &amp;= 0xFFFF;
        }
    }   /* end for length */
    for ( i=0; i&lt;FNV512size/2; ++i )
        ctx-&gt;Hash[i] = (uint16_t)temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV512blockin */

/* hash in a zero-terminated string not including the zero  (32-bit)
 ******************************************************************/
int FNV512stringin ( FNV512context * const ctx, const char *in ) {
    uint32_t temp[FNV512size/2];
    uint32_t temp2[11];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV512state:
            ctx-&gt;Computed = FNVcomputed+FNV512state;
            break;
        case FNVcomputed+FNV512state:
            break;
        default:
             return fnvStateError;
    }
    for ( i=0; i&lt;FNV512size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV512prime * ( temp ^ *in++ ); */
        temp[FNV512size/2-1] ^= ch;
        for ( i=0; i&lt;11; ++i )
            temp2[10-i] = temp[FNV512size/2-1-i] &lt;&lt; FNV512shift;
        for ( i=0; i&lt;FNV512size/2; ++i )
            temp[i] *= FNV512primeX;
        for ( i=0; i&lt;11; ++i )
            temp[i] += temp2[i];
        for ( i=FNV512size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16; // propagate carries
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV512size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV512stringin */

/* return hash  (32-bit)
 ******************************************************************/
int FNV512result ( FNV512context * const ctx,
                   uint8_t out[FNV512size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV512state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV512size/2; ++i ) {
        out[2*i] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[2*i+1] = ctx-&gt;Hash[i];
        ctx-&gt;Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV512state;
    return fnvSuccess;
}   /* end FNV512result */

#endif    /*  FNV_64bitIntegers */
//*****************************************************************
// END VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//*****************************************************************

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.5-3" class="pilcrow">¶</a>
</div>
</section>
<section id="section-8.2.6">
          <h4 id="name-fnv1024-code">
<a href="#section-8.2.6" class="section-number selfRef">8.2.6. </a><a href="#name-fnv1024-code" class="section-name selfRef">FNV1024 Code</a>
          </h4>
<p id="section-8.2.6-1">The following code is the header and C source for 1024-bit FNV-1a providing a byte
vector hash.<a href="#section-8.2.6-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.2.6-2">
<pre>&lt;CODE BEGINS&gt; file "FNV1024.h"

//*********************** FNV1024.h ***********************//
//************* See RFC 9923 for details. *****************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#ifndef _FNV1024_H_
#define _FNV1024_H_

/*
 *  Description:
 *      This file provides headers for the 1024-bit version of
 *      the FNV-1a non-cryptographic hash algorithm.
 */

#include "FNVconfig.h"
#include "FNVErrorCodes.h"

#include &lt;stdint.h&gt;
#define FNV1024size (1024/8)

/* If you do not have the ISO standard stdint.h header file, then
 * you must typedef the following types:
 *
 *    type              meaning
 *  uint64_t    unsigned 64-bit integer (ifdef FNV_64bitIntegers)
 *  uint32_t    unsigned 32-bit integer
 *  uint16_t    unsigned 16-bit integer
 *  uint8_t     unsigned 8-bit integer (i.e., unsigned char)
 */

/*
 *  This structure holds context information for an FNV1024 hash
 */
#ifdef FNV_64bitIntegers
    /* version if 64-bit integers supported */
typedef struct FNV1024context_s {
        int Computed;  /* state */
        uint32_t Hash[FNV1024size/4];
} FNV1024context;

#else
    /* version if 64-bit integers NOT supported */
typedef struct FNV1024context_s {
        int Computed;  /* state */
        uint16_t Hash[FNV1024size/2];
} FNV1024context;

#endif /* FNV_64bitIntegers */

/*  Function Prototypes:
 *
 *    FNV1024string: hash a zero-terminated string not including
 *                   the terminating zero
 *    FNV1024stringBasis: also takes an offset_basis parameter
 *
 *    FNV1024block: hash a byte vector of a specified length
 *    FNV1024blockBasis: also takes an offset_basis parameter
 *
 *    FNV1024file: hash the contents of a file
 *    FNV1024fileBasis: also takes an offset_basis parameter
 *
 *    FNV1024init: initializes an FNV1024 context
 *    FNV1024initBasis: initializes an FNV1024 context with a
 *                      provided 128-byte vector basis
 *    FNV1024blockin: hash in a byte vector of a specified length
 *    FNV1024stringin: hash in a zero-terminated string not
 *                     including the terminating zero
 *    FNV1024filein: hash in the contents of a file
 *    FNV1024result: returns the hash value
 *
 *    Hash is returned as an array of 8-bit unsigned integers
 */

#ifdef __cplusplus
extern "C" {
#endif

/* FNV1024 */
extern int FNV1024string ( const char *in,
                           uint8_t out[FNV1024size] );
extern int FNV1024stringBasis ( const char *in,
                                uint8_t out[FNV1024size],
                                const uint8_t basis[FNV1024size] );
extern int FNV1024block ( const void *vin,
                          long int length,
                          uint8_t out[FNV1024size] );
extern int FNV1024blockBasis ( const void *vin,
                               long int length,
                               uint8_t out[FNV1024size],
                               const uint8_t basis[FNV1024size] );
extern int FNV1024file ( const char *fname,
                         uint8_t out[FNV1024size] );
extern int FNV1024fileBasis ( const char *fname,
                              uint8_t out[FNV1024size],
                              const uint8_t basis[FNV1024size] );
extern int FNV1024init ( FNV1024context * const );
extern int FNV1024initBasis ( FNV1024context * const,
                              const uint8_t basis[FNV1024size] );
extern int FNV1024blockin ( FNV1024context * const,
                            const void *vin,
                            long int length );
extern int FNV1024stringin ( FNV1024context * const,
                            const char *in );
extern int FNV1024filein ( FNV1024context * const,
                           const char *fname );
extern int FNV1024result ( FNV1024context * const,
                           uint8_t out[FNV1024size] );

#ifdef __cplusplus
}
#endif

#endif /* _FNV1024_H_ */

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.6-2" class="pilcrow">¶</a>
</div>
<div class="breakable lang-c sourcecode" id="section-8.2.6-3">
<pre>&lt;CODE BEGINS&gt; file "FNV1024.c"

//************************** FNV1024.c **************************//
//****************** See RFC 9923 for details. ******************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

/* This file implements the FNV (Fowler/Noll/Vo) non-cryptographic
 * hash function FNV-1a for 1024-bit hashes.
 */

#include &lt;stdio.h&gt;

#include "fnv-private.h"
#include "FNV1024.h"

//*****************************************************************
//  COMMON CODE FOR 64- AND 32-BIT INTEGER MODES
//*****************************************************************

/* FNV1024: hash a zero-terminated string not including the zero
 ******************************************************************/
int FNV1024string ( const char *in, uint8_t out[FNV1024size] ) {
    FNV1024context ctx;
    int error;

    if ( (error = FNV1024init ( &amp;ctx )) )
        return error;
    if ( (error = FNV1024stringin ( &amp;ctx, in )) )
        return error;
    return FNV1024result ( &amp;ctx, out );
}   /* end FNV1024string */

/* FNV1024: hash a zero-terminated string not including the zero
 * with a non-standard basis
 ******************************************************************/
int FNV1024stringBasis ( const char *in,
                         uint8_t out[FNV1024size],
                         const uint8_t basis[FNV1024size] ) {
    FNV1024context ctx;
    int error;

    if ( (error = FNV1024initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV1024stringin ( &amp;ctx, in )) )
        return error;
    return FNV1024result ( &amp;ctx, out );
}   /* end FNV1024stringBasis */

/* FNV1024: hash a counted block  (64/32-bit)
 ******************************************************************/
int FNV1024block ( const void *vin,
                   long int length,
                   uint8_t out[FNV1024size] ) {
    FNV1024context ctx;
    int error;

    if ( (error = FNV1024init ( &amp;ctx )) )
        return error;
    if ( (error = FNV1024blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV1024result ( &amp;ctx, out );
}   /* end FNV1024block */

/* FNV1024: hash a counted block  (64/32-bit)
 * with a non-standard basis
 ******************************************************************/
int FNV1024blockBasis ( const void *vin,
                        long int length,
                        uint8_t out[FNV1024size],
                        const uint8_t basis[FNV1024size] ) {
    FNV1024context ctx;
    int error;

    if ( (error = FNV1024initBasis ( &amp;ctx, basis )) )
        return error;
    if ( (error = FNV1024blockin ( &amp;ctx, vin, length)) )
        return error;
    return FNV1024result ( &amp;ctx, out );
}   /* end FNV1024blockBasis */

/* hash the contents of a file
 ******************************************************************/
int FNV1024file ( const char *fname,
                  uint8_t out[FNV1024size] ) {
    FNV1024context e1024Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV1024init (&amp;e1024Context)) )
        return error;
    if ( (error = FNV1024filein (&amp;e1024Context, fname)) )
        return error;
    return FNV1024result ( &amp;e1024Context, out );
}   /* end FNV1024file */

/* hash the contents of a file with a non-standard basis
 ******************************************************************/
int FNV1024fileBasis ( const char *fname,
                       uint8_t out[FNV1024size],
                       const uint8_t basis[FNV1024size] ) {
    FNV1024context e1024Context;
    int error;

    if ( !out )
        return fnvNull;
    if ( (error = FNV1024initBasis (&amp;e1024Context, basis)) )
        return error;
    if ( (error = FNV1024filein (&amp;e1024Context, fname)) )
        return error;
    return FNV1024result ( &amp;e1024Context, out );
}   /* end FNV1024fileBasis */

/* hash in the contents of a file
 ******************************************************************/
int FNV1024filein ( FNV1024context * const e1024Context,
                    const char *fname ) {
    FILE *fp;
    long int i;
    char buf[1024];
    int error;

    if ( !e1024Context || !fname )
        return fnvNull;
    switch ( e1024Context-&gt;Computed ) {
        case FNVinited+FNV1024state:
            e1024Context-&gt;Computed = FNVcomputed+FNV1024state;
            break;
        case FNVcomputed+FNV1024state:
            break;
        default:
             return fnvStateError;
    }
    if ( ( fp = fopen ( fname, "rb") ) == NULL )
        return fnvBadParam;
    if ( (error = FNV1024blockin ( e1024Context, "", 0)) ) {
        fclose(fp);
        return error;
    }
    while ( ( i = fread ( buf, 1, sizeof(buf), fp ) ) &gt; 0 )
        if ( (error = FNV1024blockin ( e1024Context, buf, i)) ) {
            fclose(fp);
            return error;
        }
    error = ferror(fp);
    fclose(fp);
    if (error) return fnvBadParam;
    return fnvSuccess;
}   /* end FNV1024filein */

//****************************************************************//
// START VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//****************************************************************//
#ifdef FNV_64bitIntegers

/* 1024-bit FNV_prime = 2^680 + 2^8 + 0x8d =
   0x0000000000000000 0000000000000000
     0000000000000000 0000000000000000
     0000000000000000 0000010000000000
     0000000000000000 0000000000000000
     0000000000000000 0000000000000000
     0000000000000000 0000000000000000
     0000000000000000 0000000000000000
     0000000000000000 000000000000018D */
#define FNV1024primeX 0x018D
#define FNV1024shift 8

//***************************************************************//
//         Set of init, input, and output functions below
//         to incrementally compute FNV1024
//**************************************************************//

/* initialize context  (64-bit)
 ******************************************************************/
int FNV1024init ( FNV1024context * const ctx ) {
    const uint32_t FNV1024basis[FNV1024size/4] = {
      0x00000000, 0x00000000, 0x005F7A76, 0x758ECC4D,
      0x32E56D5A, 0x591028B7, 0x4B29FC42, 0x23FDADA1,
      0x6C3BF34E, 0xDA3674DA, 0x9A21D900, 0x00000000,
      0x00000000, 0x00000000, 0x00000000, 0x00000000,
      0x00000000, 0x00000000, 0x00000000, 0x00000000,
      0x00000000, 0x00000000, 0x00000000, 0x0004C6D7,
      0xEB6E7380, 0x2734510A, 0x555F256C, 0xC005AE55,
      0x6BDE8CC9, 0xC6A93B21, 0xAFF4B16C, 0x71EE90B3 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV1024size/4; ++i )
        ctx-&gt;Hash[i] = FNV1024basis[i];
    ctx-&gt;Computed = FNVinited+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024init */

/* initialize context with a provided 128-byte vector basis  (64-bit)
 *******************************************************************/
int FNV1024initBasis ( FNV1024context * const ctx,
                       const uint8_t basis[FNV1024size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV1024size/4; ++i ) {
        uint32_t temp = *basis++&lt;&lt;24;
        temp += *basis++&lt;&lt;16;
        temp += *basis++&lt;&lt;8;
        ctx-&gt;Hash[i] = temp + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024initBasis */

/* hash in a counted block  (64-bit)
 ******************************************************************/
int FNV1024blockin ( FNV1024context * const ctx,
                     const void *vin,
                     long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint64_t temp[FNV1024size/4];
    uint64_t temp2[11];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV1024state:
            ctx-&gt;Computed = FNVcomputed+FNV1024state;
            break;
        case FNVcomputed+FNV1024state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV1024size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV1024prime * ( temp ^ *in++ ); */
        temp[FNV1024size/4-1] ^= *in++;
        for ( i=0; i&lt;11; ++i )
            temp2[10-i] = temp[FNV1024size/4-1-i] &lt;&lt; FNV1024shift;
        for ( i=0; i&lt;FNV1024size/4; ++i )
            temp[i] *= FNV1024primeX;
        for ( i=0; i&lt;11; ++i )
            temp[i] += temp2[i];
        for ( i=FNV1024size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;  // propagate carries
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }   /* end for length */
    for ( i=0; i&lt;FNV1024size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV1024blockin */

/* hash in a zero-terminated string not including the zero  (64-bit)
 ******************************************************************/
int FNV1024stringin ( FNV1024context * const ctx, const char *in ) {
    uint64_t temp[FNV1024size/4];
    uint64_t temp2[11];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV1024state:
            ctx-&gt;Computed = FNVcomputed+FNV1024state;
            break;
        case FNVcomputed+FNV1024state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV1024size/4; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV1024prime * ( temp ^ ch ); */
        temp[FNV1024size/4-1] ^= ch;
        for ( i=0; i&lt;11; ++i )
            temp2[10-i] = temp[FNV1024size/4-1-i] &lt;&lt; FNV1024shift;
        for ( i=0; i&lt;FNV1024size/4; ++i )
            temp[i] *= FNV1024primeX;
        for ( i=0; i&lt;11; ++i )
                temp[i] += temp2[i];
        for ( i=FNV1024size/4-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 32;
            temp[i] &amp;= 0xFFFFFFFF;
        }
    }
    for ( i=0; i&lt;FNV1024size/4; ++i )
        ctx-&gt;Hash[i] = (uint32_t)temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV1024stringin */

/* return hash  (64-bit)
 ******************************************************************/
int FNV1024result ( FNV1024context * const ctx,
                    uint8_t out[FNV1024size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV1024state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV1024size/4; ++i ) {
        out[4*i] = ctx-&gt;Hash[i] &gt;&gt; 24;
        out[4*i+1] = ctx-&gt;Hash[i] &gt;&gt; 16;
        out[4*i+2] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[4*i+3] = ctx-&gt;Hash[i];
        ctx -&gt; Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024result */

//****************************************************************//
// END VERSION FOR WHEN YOU HAVE 64-BIT ARITHMETIC
//****************************************************************//
#else    /*  FNV_64bitIntegers */
//****************************************************************//
// START VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//****************************************************************//

/*
 1024-bit FNV_prime = 2^680 + 2^8 + 0x8d =
   0x00000000 00000000 00000000 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000100 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000000 00000000
     00000000 00000000 00000000 0000018D */
#define FNV1024primeX 0x018D
#define FNV1024shift 8

//*****************************************************************
//         Set of init, input, and output functions below
//         to incrementally compute FNV1024
//*****************************************************************

/* initialize context  (32-bit)
 ******************************************************************/
int FNV1024init ( FNV1024context * const ctx ) {
    const uint16_t FNV1024basis[FNV1024size/2] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x005F, 0x7A76, 0x758E, 0xCC4D,
0x32E5, 0x6D5A, 0x5910, 0x28B7, 0x4B29, 0xFC42, 0x23FD, 0xADA1,
0x6C3B, 0xF34E, 0xDA36, 0x74DA, 0x9A21, 0xD900, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0xC6D7,
0xEB6E, 0x7380, 0x2734, 0x510A, 0x555F, 0x256C, 0xC005, 0xAE55,
0x6BDE, 0x8CC9, 0xC6A9, 0x3B21, 0xAFF4, 0xB16C, 0x71EE, 0x90B3 };

    if ( !ctx )
        return fnvNull;
    for ( int i=0; i&lt;FNV1024size/2; ++i )
        ctx-&gt;Hash[i] = FNV1024basis[i];
    ctx-&gt;Computed = FNVinited+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024init */

/* initialize context with a provided 128-byte vector basis  (32-bit)
 *******************************************************************/
int FNV1024initBasis ( FNV1024context * const ctx,
                       const uint8_t basis[FNV1024size] ) {
    if ( !ctx || !basis )
        return fnvNull;
    for ( int i=0; i &lt; FNV1024size/2; ++i ) {
        uint32_t temp = *basis++;
        ctx-&gt;Hash[i] = ( temp&lt;&lt;8 ) + *basis++;
    }
    ctx-&gt;Computed = FNVinited+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024initBasis */

/* hash in a counted block  (32-bit)
 ******************************************************************/
int FNV1024blockin ( FNV1024context * const ctx,
                    const void *vin,
                    long int length ) {
    const uint8_t *in = (const uint8_t*)vin;
    uint32_t temp[FNV1024size/2];
    uint32_t temp2[22];
    int i;

    if ( !ctx || !in )
        return fnvNull;
    if ( length &lt; 0 )
        return fnvBadParam;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV1024state:
            ctx-&gt;Computed = FNVcomputed+FNV1024state;
            break;
        case FNVcomputed+FNV1024state:
            break;
        default:
            return fnvStateError;
    }
    for ( i=0; i&lt;FNV1024size/2; ++i )
        temp[i] = ctx-&gt;Hash[i];  // copy into temp
    for ( ; length &gt; 0; length-- ) {
        /* temp = FNV1024prime * ( temp ^ *in++ ); */
        temp[FNV1024size/2-1] ^= *in++;
        for ( i=0; i&lt;22; ++i )
            temp2[21-i] = temp[FNV1024size/2-1-i] &lt;&lt; FNV1024shift;
        for ( i=0; i&lt;FNV1024size/2; ++i )
            temp[i] *= FNV1024primeX;
        for ( i=0; i&lt;22; ++i )
            temp[i] += temp2[i];
        for ( i=FNV1024size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16; // propagate carries
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV1024size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV1024blockin */

/* hash in a zero-terminated string not including the zero  (32-bit)
 ******************************************************************/
int FNV1024stringin ( FNV1024context * const ctx, const char *in ) {
    uint32_t temp[FNV1024size/2];
    uint32_t temp2[22];
    int i;
    uint8_t ch;

    if ( !ctx || !in )
        return fnvNull;
    switch ( ctx-&gt;Computed ) {
        case FNVinited+FNV1024state:
            ctx-&gt;Computed = FNVcomputed+FNV1024state;
            break;
        case FNVcomputed+FNV1024state:
            break;
        default:
             return fnvStateError;
    }
    for ( i=0; i&lt;FNV1024size/2; ++i )
         temp[i] = ctx-&gt;Hash[i];  // copy into temp
    while ( (ch = (uint8_t)*in++) ) {
        /* temp = FNV1024prime * ( temp ^ *in++ ); */
        temp[FNV1024size/2-1] ^= ch;
        for ( i=0; i&lt;22; ++i )
            temp2[21-i] = temp[FNV1024size/2-1-i] &lt;&lt; FNV1024shift;
        for ( i=0; i&lt;FNV1024size/2; ++i )
            temp[i] *= FNV1024primeX;
        for ( i=0; i&lt;22; ++i )
             temp[i] += temp2[i];
        for ( i=FNV1024size/2-1; i&gt;0; --i ) {
            temp[i-1] += temp[i] &gt;&gt; 16; // propagate carries
            temp[i] &amp;= 0xFFFF;
        }
    }
    for ( i=0; i&lt;FNV1024size/2; ++i )
        ctx-&gt;Hash[i] = temp[i];  // store back into hash
    return fnvSuccess;
}   /* end FNV1024stringin */

/* return hash  (32-bit)
 ******************************************************************/
int FNV1024result ( FNV1024context * const ctx,
                    uint8_t out[FNV1024size] ) {
    if ( !ctx || !out )
        return fnvNull;
    if ( ctx-&gt;Computed != FNVcomputed+FNV1024state )
        return fnvStateError;
    for ( int i=0; i&lt;FNV1024size/2; ++i ) {
        out[2*i] = ctx-&gt;Hash[i] &gt;&gt; 8;
        out[2*i+1] = ctx-&gt;Hash[i];
        ctx-&gt;Hash[i] = 0;
    }
    ctx-&gt;Computed = FNVemptied+FNV1024state;
    return fnvSuccess;
}   /* end FNV1024result */

#endif    /*  FNV_64bitIntegers */
//****************************************************************//
// END VERSION FOR WHEN YOU ONLY HAVE 32-BIT ARITHMETIC
//****************************************************************//

&lt;CODE ENDS&gt;</pre><a href="#section-8.2.6-3" class="pilcrow">¶</a>
</div>
</section>
</section>
</div>
<div id="sec-8.3">
<section id="section-8.3">
        <h3 id="name-fnv-test-code">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-fnv-test-code" class="section-name selfRef">FNV Test Code</a>
        </h3>
<p id="section-8.3-1">Below is source code for a test driver with a command line
interface as documented in <a href="#sec-8.1.3" class="auto internal xref">Section 8.1.3</a>. By default, with no command
line arguments, it runs tests of all FNV lengths.<a href="#section-8.3-1" class="pilcrow">¶</a></p>
<div class="breakable lang-c sourcecode" id="section-8.3-2">
<pre>&lt;CODE BEGINS&gt; file "main.c"

//************************* Main.c **************************//
//*************** See RFC 9923 for details. *****************//
/* Copyright (c) 2016-2025 IETF Trust and the persons
 * identified as authors of the code.  All rights reserved.
 * See fnv-private.h for terms of use and redistribution.
 */

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

/* To do a thorough test, you need to run with
 * FNV_64bitIntegers defined and with it undefined
 */
#include "FNVconfig.h"
#include "fnv-private.h"
#include "FNV32.h"
#include "FNV64.h"
#include "FNV128.h"
#include "FNV256.h"
#include "FNV512.h"
#include "FNV1024.h"

/* global variables */
char             *funcName = "funcName not set?";
const char       *errteststring = "foo";
int              Terr = -1; /* Total errors */
int              verbose = 0; /* Verbose flag */
enum { FNV32selected = 0, FNV64selected, FNV128selected,
       FNV256selected, FNV512selected, FNV1024selected,
       FNVnone = -1 } selected = FNVnone;
#define NTestBytes 3
const uint8_t   errtestbytes[NTestBytes] = { (uint8_t)1,
    (uint8_t)2, (uint8_t)3 };

// initial teststring is null, so initial result is offset_basis
const char *teststring[] = {
        "",
        "a",
        "foobar",
        "Hello!\x01\xFF\xED"
};
#define NTstrings (sizeof(teststring)/sizeof(char *))

// due to FNV-1 versus FNV1a, XOR in final backslash separately
const char      BasisString[] = "chongo &lt;Landon Curt Noll&gt; /\\../";
FNV32context    e32Context;
uint32_t        eUint32 = 42;
#ifdef FNV_64bitIntegers
  uint64_t      eUint64 = 42;
#endif
FNV64context    e64Context;
FNV128context   e128Context;
FNV256context   e256Context;
FNV512context   e512Context;
FNV1024context  e1024Context;
uint8_t         hash[FNV1024size];  /* largest size needed */
uint8_t         FakeBasis[FNV1024size];
uint8_t         ZeroBasis[FNV1024size];
char            tempFileNameTemplate[] = "tmp.XXXXXXXXXX";
const char      *tempFileName = 0;

//****************************************************************
// local prototypes in alphabetical order
//****************************************************************
void CommonTest ( void );
void ErrTestReport ( void );
int find_selected(const char *optarg);
void HexPrint ( int count, const uint8_t *ptr );
void TestAll ( void );
void Test32 ( void );
void Test64 ( void );
void Test128 ( void );
void Test256 ( void );
void Test512 ( void );
void Test1024 ( void );
void TestNValue ( const char *subfunc,  // test calculated value
                  const char *string,
                  int N,                // size
                  const uint8_t *was,
                  const uint8_t should[N] );
int TestR ( const char *,
            int expect,
            int actual ); // test return code
void usage( const char *argv0 ); // print help message
void ValueTestReport ( void );      // print test results

#ifndef FNV_64bitIntegers
# undef uint64
# define uint64_t no_64_bit_integers
#endif /* FNV_64bitIntegers */

// array of function pointers, etc.
struct { // sometimes indexed into by the enum variable "selected"
    int length;
    void (*Testfunc)( void );
    int (*Stringfunc)( const char *, uint8_t *); // string
    int (*Blockfunc)( const void *, long int, uint8_t *); // block
    int (*Filefunc)( const char *, uint8_t *); // file
    int (*StringBasisfunc)
        ( const char *, uint8_t *, const uint8_t *); // stringBasis
    int (*BlockBasisfunc)
        (const void *, long int, uint8_t *,
         const uint8_t *); // blockBasis
    int (*FileBasisfunc)
        (const char *, uint8_t *, const uint8_t *); // fileBlock
} funcmap[] = {  // valid sizes
    { 32, Test32, FNV32string, FNV32block, FNV32file,
      FNV32stringBasis, FNV32blockBasis, FNV32fileBasis },
    { 64, Test64, FNV64string, FNV64block, FNV64file,
      FNV64stringBasis, FNV64blockBasis, FNV64fileBasis },
    { 128, Test128, FNV128string, FNV128block, FNV128file,
      FNV128stringBasis, FNV128blockBasis, FNV128fileBasis },
    { 256, Test256, FNV256string, FNV256block, FNV256file,
      FNV256stringBasis, FNV256blockBasis, FNV256fileBasis },
    { 512, Test512, FNV512string, FNV512block, FNV512file,
      FNV512stringBasis, FNV512blockBasis, FNV512fileBasis },
    { 1024, Test1024, FNV1024string, FNV1024block, FNV1024file,
      FNV1024stringBasis, FNV1024blockBasis, FNV1024fileBasis },
    { 0, Test32, FNV32string, FNV32block, FNV32file }  // fence post
};

//****************************************************************
//  main
//****************************************************************
int main( int argc, const char **argv ) {
    int option;  // command line option letter
    int i;
    uint16_t endianness = 5*256 + 11;

    mkstemp(tempFileNameTemplate);
    tempFileName = tempFileNameTemplate;

    if ( ((uint8_t *)&amp;endianness)[0] != 11 )
        printf ("Coded for little endian but computer seems\n"
                " to be big endian!  Multi-byte integer results\n"
                " may be incorrect!\n");
    for ( i=0; i&lt;FNV1024size; ++i ) {// initialize a couple of arrays
        ZeroBasis[i] = 0;
        FakeBasis[i] = (uint8_t)i;
    }
    if ( argc == 1 ) {  // if no arguments
       TestAll();
        if ( tempFileName )
            unlink(tempFileName);
        exit(0);
     }

// process command line options
//*****************************************************************
    while ((option = getopt(argc, (char *const *)argv, ":af:ht:u:v"))
           != -1) {
        if ( verbose )
            printf ( "Got option %c\n", option );
        switch ( option ) {
            case 'a':   // run all tests
                TestAll();
                break;
            case 'f':   // followed by name of file to hash
                if ( selected == FNVnone ) {
                    printf ( "No hash size selected.\n" );
                    break;
                }
                printf ( "FNV-%i Hash of contents of file '%s':\n",
                         funcmap[selected].length, optarg );
                if ( funcmap[selected].Filefunc ( optarg, hash ))
                    printf ( "Hashing file '%s' fails: %s.\n",
                        optarg, strerror(errno) );
                else
                    HexPrint ( funcmap[selected].length/8, hash );
                printf ( "\n" );
                break;
            case 'h':   // help
                usage( argv[0] );
                break;
            case 't':   // followed by size of FNV to test, 0-&gt;all
                selected = find_selected(optarg);
                if (selected == FNVnone)
                    printf ( "Bad argument to option -t\n"
                             "Valid sizes are 32, 64, 128,"
                             " 256, 512, and 1024\n" );
                else
                    funcmap[selected].Testfunc();   // invoke test
                break;
            case 'u':   // followed by size of FNV to use
                selected = find_selected(optarg);
                if ( selected == FNVnone )
                    printf ( "Bad argument to option -u\n"
                             "Valid sizes are 32, 64, 128,"
                             " 256, 512, and 1024\n" );
                break;
            case 'v':   // toggle Verbose flag
                if ( (verbose ^= 1) ) {
                    printf ( "Verbose on.\n" );
#ifdef FNV_64bitIntegers
                    printf ("Has 64-bit integers. ");
#else
                    printf ("Does not have 64-bit integers. ");
#endif
                    // also tests the TestR function
                    funcName = "Testing TestR";
                    TestR ( "should fail", 1, 2 );
                    TestR ( "should not have failed", 3, 3 );
                }
                else
                    printf ( "Verbose off.\n" );
                break;
            case '?':   //
                printf ( "Unknown option %c\n", optopt );
                usage( argv[0] );
                return 1;
        }  /* end switch */
    }  /* end while */
    if ( ( option == -1 ) &amp;&amp; verbose )
        printf ( "No more options.\n" );

// Through all the options, now, if a size is set, encrypt any
//   other tokens on the command line
//******************************************************
    for ( i = optind; i &lt; argc; ++i ) {
        int rc;  // return code

        if ( selected == FNVnone ) {
            printf ( "No hash size selected.\n" );
            break;  // out of for
        }
        rc = funcmap[selected].Stringfunc(argv[i], hash);
        if ( rc )
            printf ( "FNV-%i of '%s' returns error %i\n",
                    funcmap[selected].length,
                    argv[i], rc );
        else {
            printf ( "FNV-%i of '%s' is ",
                    funcmap[selected].length, argv[i] );
            HexPrint ( funcmap[selected].length/8, hash );
            printf ( "\n" );
        }
    }
    if ( tempFileName )
        unlink(tempFileName);
    return 0;
}   /* end main */

/* Write to a temp file
 ******************************************************************/
const char *WriteTemp( const char *str, long int iLen ) {
    FILE *fp = fopen( tempFileName, "w" );
    if (!fp) {
        printf ( "Cannot open tempfile: %s: %s\n",
                 tempFileName, strerror(errno) );
        return 0;
    }
    long int ret = fwrite( str, 1, iLen, fp );
    fclose(fp);
    if ( ret != iLen ) {
        printf ( "Cannot write tempfile: %s: %s\n",
                 tempFileName, strerror(errno) );
        return 0;
    }
    return tempFileName;
}

//****************************************************************
//  Test status return code
//****************************************************************
int TestR ( const char *name, int expect, int actual ) {
    if ( expect != actual ) {
        printf ( "%s %s returned %i instead of %i.\n",
                 funcName, name, actual, expect );
        ++Terr;  /* increment error count */
        }
    return actual;
}    /* end TestR */

//****************************************************************
//  General byte vector return value test
//****************************************************************
void TestNValue ( const char *subfunc,
                  const char *string, // usually what was hashed
                  int N,
                  const uint8_t was[N],
                  const uint8_t should[N] ) {
    if ( memcmp ( was, should, N ) != 0 ) {
        ++Terr;
        printf ( "%s %s of '%s'",
                funcName, subfunc, string );
        printf ( " computed " );
        HexPrint ( N, was );
        printf ( ", expected " );
        HexPrint ( N, should );
        printf ( ".\n" );
    }
    else if ( verbose ) {
        printf ( "%s %s of '%s' computed ",
                funcName, subfunc, string );
        HexPrint ( N, was );
        printf ( " as expected.\n" );
    }
}   /* end TestNValue */

//****************************************************************
//  Reports on status/value returns
//****************************************************************
void ErrTestReport ( void ) {
    if ( Terr )
        printf ( "%s test of error checks failed %i times.\n",
                funcName, Terr );
    else if ( verbose )
        printf ( "%s test of error checks passed.\n",
                funcName );
}  /* end ErrTestReport */

void ValueTestReport ( void ) {
    if ( Terr )
        printf ( "%s test of return values failed %i times.\n",
                funcName, Terr );
    else
        printf ( "%s test of return values passed.\n", funcName );
}  /* end ValueTestReport */

//****************************************************************
//  Verify the size of hash as a command line option argument
//    and return the index in funcmap[], -1 if not found.
//****************************************************************
int find_selected(const char *optarg) {
    int argval, count;

    count = sscanf ( optarg, "%i", &amp;argval );
    if ( count &gt; 0 ) {
      int i;
        for ( i = 0; funcmap[i].length; ++i ) {
            if ( funcmap[i].length == argval ) {
                return i;
            }  /* end if */
        }  /* end for */
    }
    return FNVnone;
}   /* end find_selected */

//****************************************************************
//  Print some bytes as hexadecimal
//****************************************************************
void HexPrint( int count, const uint8_t *ptr ) {
    for ( int i = 0; i &lt; count; ++i )
        printf ( "%02X", ptr[i] );
}   /* end HexPrint */

//****************************************************************
//  Test all sizes
//****************************************************************
void TestAll ( void ) {
    for ( int i=0; funcmap[i].length; ++i )
        funcmap[i].Testfunc ();
}   /* end TestAll */

//****************************************************************
//  Common error check tests
//****************************************************************
void CommonTest ( void ) {
    TestR ( "string1b", fnvNull,
        funcmap[selected].Stringfunc ( (char *)0, hash ) );
    TestR ( "string2b", fnvNull,
        funcmap[selected].Stringfunc ( errteststring,
                                      (uint8_t *)0 ) );
    TestR ( "strBasis1b", fnvNull,
           funcmap[selected].StringBasisfunc ( (char *)0,
               hash, FakeBasis ) );
    TestR ( "strBasis2b", fnvNull,
           funcmap[selected].StringBasisfunc ( errteststring,
               (uint8_t *)0, FakeBasis ) );
    TestR ( "strBasis3b", fnvNull,
           funcmap[selected].StringBasisfunc ( errteststring,
               hash, (uint8_t *)0 ) );
    TestR ( "blk1", fnvNull,
        funcmap[selected].Blockfunc ( (uint8_t *)0, 1, hash ) );
    TestR ( "blk2", fnvBadParam,
        funcmap[selected].Blockfunc ( errtestbytes, -1, hash ) );
    TestR ( "blk3", fnvNull,
        funcmap[selected].Blockfunc ( errtestbytes, 1,
                                     (uint8_t *)0 ) );
    TestR ( "blk1b", fnvNull,
        funcmap[selected].BlockBasisfunc ( (uint8_t *)0, 1,
                                           hash, FakeBasis ) );
    TestR ( "blk2b", fnvBadParam,
        funcmap[selected].BlockBasisfunc ( errtestbytes, -1,
                                           hash, FakeBasis ) );
    TestR ( "blk3b", fnvNull,
        funcmap[selected].BlockBasisfunc ( errtestbytes, 1,
                                     (uint8_t *)0, FakeBasis ) );
    TestR ( "blk4b", fnvNull,
        funcmap[selected].BlockBasisfunc ( errtestbytes, 1,
                                           hash, (uint8_t *)0 ) );
    TestR ( "file1", fnvNull,
        funcmap[selected].Filefunc ( (char *)0, hash ) );
    TestR ( "file2", fnvNull,
        funcmap[selected].Filefunc ( "foo.txt", (uint8_t *)0 ) );
    TestR ( "file1b", fnvNull,
        funcmap[selected].FileBasisfunc ( (char *)0, hash,
                                          FakeBasis ) );
    TestR ( "file2b", fnvNull,
        funcmap[selected].FileBasisfunc ( "foo.txt", (uint8_t *)0,
                                          FakeBasis ) );
    TestR ( "file3b", fnvNull,
        funcmap[selected].FileBasisfunc ( "foo.txt", hash,
                                         (uint8_t *)0 ) );
}   /* end CommonTest */

//****************************************************************
//  Print command line help
//****************************************************************
void usage( const char *argv0 ) {
    printf (
        "%s [-a] [-t nnn] [-u nnn] [-v] [-f filename] [token ...]\n"
        "  -a = run all tests\n"
        "  -f filename = hash file contents\n"
        "  -h = help, print this message\n"
        "  -t nnn = Test hash size nnn\n"
        "  -u nnn = Use hash size nnn\n"
        "  -v = toggle Verbose flag\n"
        "  Each token is hashed.\n", argv0 );
}   /* end usage */

//****************************************************************
//  Test Macros
//****************************************************************

// test for return values
//************************
#define TestInit(INIT,CTX,CTXT)                                 \
TestR ( "init1", fnvSuccess, INIT ( &amp;CTX ) );                   \
TestR ( "init2", fnvNull, INIT ( (CTXT *)0 ) );

#define TestInitBasis(INITB,CTX,CTXT)                           \
TestR ( "initB1", fnvSuccess, INITB (&amp;CTX, FakeBasis ) );       \
TestR ( "initB2", fnvNull, INITB ( (CTXT *)0, hash ) );         \
TestR ( "initB3", fnvNull, INITB ( &amp;CTX, (uint8_t *)0 ) );

#define TestBlockin(BLKIN,CTX,CTXT)                             \
TestR ( "blockin1", fnvNull,                                    \
    BLKIN ( (CTXT *)0, errtestbytes, NTestBytes ) );            \
TestR ( "blockin2", fnvNull,                                    \
    BLKIN ( &amp;CTX, (uint8_t *)0, NTestBytes ) );                 \
TestR ( "blockin3", fnvBadParam,                                \
    BLKIN ( &amp;CTX, errtestbytes, -1 ) );                         \
TestR ( "blockin4", fnvStateError,                              \
    BLKIN ( &amp;CTX, errtestbytes, NTestBytes ) );

#define TestStringin(STRIN,CTX,CTXT)                            \
TestR ( "stringin1", fnvNull,                                   \
    STRIN ( (CTXT *)0, errteststring ) );                       \
TestR ( "stringin2", fnvNull, STRIN ( &amp;CTX, (char *)0 ) );      \
TestR ( "stringin3", fnvStateError,                             \
    STRIN ( &amp;CTX, errteststring ) );

#define TestFilein(FLIN,CTX,CTXT)                               \
TestR ( "file1", fnvNull, FLIN ( (CTXT *)0, errteststring ) );  \
TestR ( "file2", fnvNull, FLIN ( &amp;CTX, (char *)0 ) );           \
TestR ( "file3", fnvStateError,                                 \
    FLIN ( &amp;CTX, errteststring ) );

#define TestResult(RSLT,CTX,CTXT)                               \
TestR ( "result1", fnvNull, RSLT ( (CTXT *)0, hash ) );         \
TestR ( "result2", fnvNull, RSLT ( &amp;CTX, (uint8_t *)0 ) );      \
TestR ( "result3", fnvStateError,                               \
            FNV128result ( &amp;e128Context, hash ) );

// test return values for INT versions including non-std basis
//*************************************************************
#define TestINT(STRINT,STRINTB,BLKINT,BLKINTB,INITINTB,         \
                INTV,INTVT,ctxT)                                \
TestR ( "string1i", fnvNull, STRINT ( (char *)0, &amp;INTV ) );     \
TestR ( "string2i", fnvNull,                                    \
        STRINT ( errteststring, (INTVT *)0 ) );                 \
TestR ( "string3i", fnvNull, STRINTB ((char *)0, &amp;INTV, INTV) );\
TestR ( "string4i", fnvNull,                                    \
        STRINTB (errteststring, (INTVT *)0, INTV) );            \
TestR ( "block1i", fnvNull, BLKINT ( (uint8_t *)0, 1, &amp;INTV ) );\
TestR ( "block2i", fnvBadParam,                                 \
        BLKINT ( errtestbytes, -1, &amp;INTV ) );                   \
TestR ( "block3i", fnvNull,                                     \
        BLKINT ( errtestbytes, 1, (INTVT *)0 ) );               \
TestR ( "block4i", fnvNull,                                     \
        BLKINTB ( (uint8_t *)0, 1, &amp;INTV, INTV ) );             \
TestR ( "block5i", fnvBadParam,                                 \
        BLKINTB ( errtestbytes, -1, &amp;INTV, INTV ) );            \
TestR ( "block6i", fnvNull,                                     \
        BLKINTB ( errtestbytes, 1, (INTVT *)0, INTV ) );        \
TestR ( "initBasis1i", fnvNull, INITINTB ( (ctxT *)0, INTV ) );

#define TestINTrf(RSLTINT,FILEINT,FILEINTB,                     \
                  ctx,ctxT,INTV,INTVT)                          \
TestR ( "result1i", fnvNull, RSLTINT ( (ctxT *)0, &amp;INTV ) );    \
TestR ( "result2i", fnvNull, RSLTINT ( &amp;ctx, (INTVT *)0 ) );    \
TestR ( "result3i", fnvStateError, RSLTINT ( &amp;ctx, &amp;INTV ) );   \
TestR ( "file1i", fnvNull, FILEINT ( (char *)0, &amp;INTV ) );      \
TestR ( "file2i", fnvNull, FILEINT ( "foo.txt", (INTVT *)0 ) ); \
TestR ( "file3i", fnvNull, FILEINTB ( (char *)0, &amp;INTV, INTV) );\
TestR ( "file4i", fnvNull,                                      \
        FILEINTB ( "foo.txt", (INTVT *)0, INTV ) );

// test to calculate standard basis from basis zero FNV-1
// depends on zero basis making the initial multiply a no-op
//*****************************
#define BasisZero(STRING,SIZ,VALUE)                             \
err = TestR ( "fnv0s", fnvSuccess,                              \
              STRING ( BasisString, hash, ZeroBasis ) );        \
if ( err == fnvSuccess ) {                                      \
    hash[SIZ-1] ^= '\\';                                        \
    TestNValue ( "fnv0sv", BasisString, SIZ, hash, VALUE[0] );  \
}
#define BasisINTZero(STRINT,SIZ,VALUE,INTV,INTVT)               \
err = TestR ( "fnv0s", fnvSuccess,                              \
              STRINT ( BasisString, &amp;INTV, (INTVT) 0 ) );       \
if ( err == fnvSuccess ) {                                      \
    INTV ^= '\\';                                               \
    TestNValue ( "fnv0svi", BasisString, SIZ,                   \
                (uint8_t *)&amp;INTV, (uint8_t *)&amp;VALUE[0] );       \
}

// test for return hash values
//*****************************
#define TestSTRBLKHash(STR,BLK,SVAL,BVAL,SZ)                    \
if ( TestR ( "stringa", fnvSuccess,                             \
             STR ( teststring[i], hash ) ) )                    \
    printf ( "  Index = %i\n", i );                             \
else                                                            \
    TestNValue ( "stringb", teststring[i], SZ,                  \
                 hash, (uint8_t *)&amp;SVAL[i] );                   \
if ( TestR ( "blocka", fnvSuccess, BLK ( teststring[i],         \
             (long int)(strlen(teststring[i])+1), hash ) ) )    \
    printf ( "  Index = %i\n", i );                             \
else                                                            \
    TestNValue ( "blockb", teststring[i], SZ,                   \
                 hash, (uint8_t *)&amp;BVAL[i] );

// Test incremental functions
//****************************
#define IncrHash(INIT,CTX,BLK,RSLT,INITB,STR,SZ,SVAL)           \
err = TestR ( "inita", fnvSuccess, INIT ( &amp;CTX ) );             \
if ( err ) break;                                               \
iLen = strlen ( teststring[i] );                                \
err = TestR ( "blockina", fnvSuccess,                           \
             BLK ( &amp;CTX, (uint8_t *)teststring[i], iLen/2 ) );  \
if ( err ) break;                                               \
if ( i &amp; 1 ) {                                                  \
    err = TestR ( "basisra", fnvSuccess, RSLT ( &amp;CTX, hash ) ); \
    if ( err ) break;                                           \
    err = TestR ( "basisia", fnvSuccess, INITB ( &amp;CTX, hash ) );\
    if ( err ) break;                                           \
}                                                               \
err = TestR ( "stringina", fnvSuccess, STR ( &amp;CTX,              \
              teststring[i] + iLen/2 ) );                       \
if ( err ) break;                                               \
err = TestR ( "resulta", fnvSuccess, RSLT ( &amp;CTX, hash ) );     \
if ( err ) break;                                               \
TestNValue ( "incrementala", teststring[i], SZ,                 \
             hash, (uint8_t *)&amp;SVAL[i] );

// test file hash
//*****************************
#define TestFILEHash(FILE,BVAL,SZ)                              \
err = TestR ( "fileafh", fnvSuccess,                            \
               FILE ( WriteTemp(teststring[i], iLen),           \
                      hash ) );                                 \
if ( err ) break;                                               \
TestNValue ( "filebfh", teststring[i], SZ, hash,                \
             (uint8_t *)&amp;BVAL[i] );

//****************************************************************
//  FNV32 Test
//****************************************************************
void Test32 ( void ) {
    long int iLen;
    uint32_t FNV32svalues[NTstrings] = {
        0x811c9dc5, 0xe40c292c, 0xbf9cf968, 0xfd9d3881 };
    uint32_t FNV32bvalues[NTstrings] = {
        0x050c5d1f, 0x2b24d044, 0x0c1c9eb8, 0xbf7ff313 };
    int i, err;
    uint8_t FNV32basisT[FNV32size] = {0xC5, 0x9D, 0x1C, 0x81 };

    funcName = "FNV-32";
    selected = FNV32selected;
/* test error checks */
    Terr = 0;
    TestInit (FNV32init, e32Context, FNV32context)
    TestInitBasis (FNV32initBasis, e32Context, FNV32context)
    CommonTest();
    TestINT (FNV32INTstring, FNV32INTstringBasis, FNV32INTblock,
             FNV32INTblockBasis, FNV32INTinitBasis, eUint32,
             uint32_t, FNV32context)
    e32Context.Computed = FNVclobber+FNV32state;
    TestBlockin (FNV32blockin, e32Context, FNV32context)
    TestStringin (FNV32stringin, e32Context, FNV32context)
    TestFilein (FNV32filein, e32Context, FNV32context)
    TestResult (FNV32result, e32Context, FNV32context)
    TestINTrf(FNV32INTresult,FNV32INTfile,FNV32INTfileBasis,
              e32Context,FNV32context,eUint32,uint32_t)
    ErrTestReport ();
    Terr = 0;
    err = TestR ( "fnv0s", fnvSuccess,
                 FNV32stringBasis ( BasisString, hash, ZeroBasis ) );
    if ( err == fnvSuccess ) {
        hash[0] ^= '\\';
        TestNValue ( "fnv0sv32", BasisString, FNV32size,
                     hash, (uint8_t *)&amp;FNV32svalues[0]);
    }
    BasisINTZero (FNV32INTstringBasis,FNV32size,FNV32svalues, \
                  eUint32,uint32_t)
    for ( i = 0; i &lt; NTstrings; ++i ) {
/* test actual results int */
        err = TestR ( "stringai", fnvSuccess,
                      FNV32INTstring ( teststring[i], &amp;eUint32 ) );
        if ( err == fnvSuccess )
            TestNValue ( "stringbi", teststring[i], FNV32size,
                         (uint8_t *)&amp;eUint32,
                         (uint8_t *)&amp;FNV32svalues[i] );
        err = TestR ( "blockai", fnvSuccess,
                      FNV32INTblock ( (uint8_t *)teststring[i],
                           (unsigned long)(strlen(teststring[i])+1),
                           &amp;eUint32 ) );
        if ( err == fnvSuccess )
            TestNValue ( "blockbi", teststring[i], FNV32size,
                         (uint8_t *)&amp;eUint32,
                         (uint8_t *)&amp;FNV32bvalues[i] );
/* test actual results byte */
        TestSTRBLKHash ( FNV32string, FNV32block, FNV32svalues,
                         FNV32bvalues, FNV32size )
/* now try testing the incremental stuff */
        IncrHash (FNV32init, e32Context, FNV32blockin, FNV32result,
            FNV32initBasis, FNV32stringin, FNV32size, FNV32svalues)
/* now try testing the incremental stuff int */
        err = TestR ( "initai", fnvSuccess,
                     FNV32init (&amp;e32Context) );
        if ( err ) break;
        iLen = strlen ( teststring[i] );
        err = TestR ( "blockinai", fnvSuccess,
                     FNV32blockin ( &amp;e32Context,
                                   (uint8_t *)teststring[i],
                                   iLen/2 ) );
        if ( err ) break;
        err = TestR ( "stringinai", fnvSuccess,
                     FNV32stringin ( &amp;e32Context,
                                    teststring[i] + iLen/2 ) );
        if ( err ) break;
        err = TestR ( "resultai", fnvSuccess,
                     FNV32INTresult ( &amp;e32Context, &amp;eUint32 ) );
        if ( err ) break;
        TestNValue ( "incrementalai", teststring[i], FNV32size,
                    (uint8_t *)&amp;eUint32,
                    (uint8_t *)&amp;FNV32svalues[i] );
/* now try testing the incremental stuff byte basis */
        err = TestR ( "initab", fnvSuccess,
                     FNV32initBasis (&amp;e32Context,
                                     (uint8_t *)&amp;FNV32basisT) );
        if ( err ) break;
        iLen = strlen ( teststring[i] );
        err = TestR ( "blockinab", fnvSuccess,
                     FNV32blockin ( &amp;e32Context,
                                   (uint8_t *)teststring[i],
                                   iLen/2 ) );
        if ( err ) break;
        err = TestR ( "stringinab", fnvSuccess,
                     FNV32stringin ( &amp;e32Context,
                                    teststring[i] + iLen/2 ) );
        if ( err ) break;
        err = TestR ( "resultab", fnvSuccess,
                     FNV32result ( &amp;e32Context, hash ) );
        if ( err ) break;
        TestNValue ( "incrementala", teststring[i], FNV32size,
                    hash, (uint8_t *)&amp;FNV32svalues[i] );
/* now try testing file hash int */
        err = TestR ( "fileafi", fnvSuccess,
                      FNV32INTfile ( WriteTemp(teststring[i], iLen),
                                     &amp;eUint32 ) );
        if ( err ) break;
        TestNValue ( "filebfi", teststring[i], FNV32size,
                         (uint8_t *)&amp;eUint32,
                         (uint8_t *)&amp;FNV32svalues[i] );

/* now try testing file hash byte */
        TestFILEHash ( FNV32file, FNV32svalues, FNV32size )
    }   // end for i
    ValueTestReport ();
}    /* end Test32 */

#ifdef FNV_64bitIntegers
//****************************************************************
//  Code for testing FNV64 using 64-bit integers
//****************************************************************
void Test64 ( void ) { /* with 64-bit integers */
    long int iLen;
    uint64_t FNV64basisT = FNV64basis;
    uint64_t FNV64svalues[NTstrings] = {
        0xcbf29ce484222325, 0xaf63dc4c8601ec8c, 0x85944171f73967e8,
        0xbd51ea7094ee6fa1 };
    uint64_t FNV64bvalues[NTstrings] = {
        0xaf63bd4c8601b7df, 0x089be207b544f1e4, 0x34531ca7168b8f38,
        0xa0a0fe4d1127ae93 };
    int i, err;

    funcName = "FNV-64";
    selected = FNV64selected;
/* test error checks */
    Terr = 0;
    TestInit (FNV64init, e64Context, FNV64context)
    TestInitBasis (FNV64initBasis, e64Context, FNV64context)
    CommonTest();
    TestINT(FNV64INTstring,FNV64INTstringBasis,FNV64INTblock,
            FNV64INTblockBasis,FNV64INTinitBasis,
            eUint64,uint64_t,FNV64context)
    e64Context.Computed = FNVclobber+FNV64state;
    TestBlockin (FNV64blockin, e64Context, FNV64context)
    TestStringin (FNV64stringin, e64Context, FNV64context)
    TestFilein (FNV64filein, e64Context, FNV64context)
    TestResult (FNV64result, e64Context, FNV64context)
    TestINTrf(FNV64INTresult,FNV64INTfile,FNV64INTfileBasis,
              e64Context,FNV64context,eUint64,uint64_t)
    ErrTestReport ();
/* test actual results int */
    Terr = 0;
    err = TestR ( "fnv0s", fnvSuccess,
                 FNV64stringBasis ( BasisString, hash, ZeroBasis ) );
    if ( err == fnvSuccess ) {
        hash[0] ^= '\\';
        TestNValue ( "fnv0sv64", BasisString, FNV64size,
                     hash, (uint8_t *)&amp;FNV64svalues[0]);
    }
    BasisINTZero (FNV64INTstringBasis,FNV64size,FNV64svalues, \
                  eUint64,uint64_t)
    for ( i = 0; i &lt; NTstrings; ++i ) {
/* test actual results int */
        err = TestR ( "stringai", fnvSuccess,
                      FNV64INTstring ( teststring[i], &amp;eUint64 ) );
        if ( err == fnvSuccess )
            TestNValue ( "stringbi", teststring[i], FNV64size,
                         (uint8_t *)&amp;eUint64,
                         (uint8_t *)&amp;FNV64svalues[i] );
        err = TestR ( "blockai", fnvSuccess,
                  FNV64INTblock ( (uint8_t *)teststring[i],
                       (unsigned long)(strlen(teststring[i])+1),
                                  &amp;eUint64 ) );
        if ( err == fnvSuccess )
            TestNValue ( "blockbi", teststring[i], FNV64size,
                         (uint8_t *)&amp;eUint64,
                         (uint8_t *)&amp;FNV64bvalues[i] );
/* test actual results byte */
        TestSTRBLKHash ( FNV64string, FNV64block, FNV64svalues,
                         FNV64bvalues, FNV64size )
/* now try testing the incremental stuff */
        IncrHash (FNV64init, e64Context, FNV64blockin, FNV64result,
            FNV64initBasis, FNV64stringin, FNV64size, FNV64svalues)
/* now try testing the incremental stuff int */
        err = TestR ( "initai", fnvSuccess,
                     FNV64init (&amp;e64Context) );
        if ( err ) break;
        iLen = strlen ( teststring[i] );
        err = TestR ( "blockinai", fnvSuccess,
                     FNV64blockin ( &amp;e64Context,
                                   (uint8_t *)teststring[i],
                                   iLen/2 ) );
        if ( err ) break;
        err = TestR ( "stringinai", fnvSuccess,
                     FNV64stringin ( &amp;e64Context,
                                    teststring[i] + iLen/2 ) );
        if ( err ) break;
        err = TestR ( "resultai", fnvSuccess,
                     FNV64INTresult ( &amp;e64Context, &amp;eUint64 ) );
        if ( err ) break;
        TestNValue ( "incrementalai", teststring[i], FNV64size,
                    (uint8_t *)&amp;eUint64,
                    (uint8_t *)&amp;FNV64svalues[i] );
/* now try testing the incremental stuff byte basis */
        err = TestR ( "initab", fnvSuccess,
                     FNV64initBasis (&amp;e64Context,
                                     (uint8_t *)&amp;FNV64basisT) );
        if ( err ) break;
        iLen = strlen ( teststring[i] );
        err = TestR ( "blockinab", fnvSuccess,
                     FNV64blockin ( &amp;e64Context,
                                   (uint8_t *)teststring[i],
                                   iLen/2 ) );
        if ( err ) break;
        err = TestR ( "stringinab", fnvSuccess,
                     FNV64stringin ( &amp;e64Context,
                                    teststring[i] + iLen/2 ) );
        if ( err ) break;
        err = TestR ( "resultab", fnvSuccess,
                     FNV64result ( &amp;e64Context, hash ) );
        if ( err ) break;
        TestNValue ( "incrementala", teststring[i], FNV64size,
                    hash, (uint8_t *)&amp;FNV64svalues[i] );
/* now try testing file int */
        err = TestR ( "fileafi", fnvSuccess,
                      FNV64INTfile ( WriteTemp(teststring[i], iLen),
                                     &amp;eUint64 ) );
        if ( err ) break;
        TestNValue ( "filebfi", teststring[i], FNV64size,
                         (uint8_t *)&amp;eUint64,
                         (uint8_t *)&amp;FNV64svalues[i] );
/* now try testing file hash */
        TestFILEHash(FNV64file,FNV64svalues,FNV64size)
    }
    ValueTestReport ();
}   /* end Test64 */

#else

//****************************************************************
//  Code for testing FNV64 without 64-bit integers
//****************************************************************
void Test64 ( void ) { /* without 64-bit integers */
    int i, err;
    long int iLen;
    uint8_t FNV64svalues[NTstrings][FNV64size] = {
        { 0xcb, 0xf2, 0x9c, 0xe4, 0x84, 0x22, 0x23, 0x25 },
        { 0xaf, 0x63, 0xdc, 0x4c, 0x86, 0x01, 0xec, 0x8c },
        { 0x85, 0x94, 0x41, 0x71, 0xf7, 0x39, 0x67, 0xe8 },
        { 0xbd, 0x51, 0xea, 0x70, 0x94, 0xee, 0x6f, 0xa1 } };
    uint8_t FNV64bvalues[NTstrings][FNV64size] = {
        { 0xaf, 0x63, 0xbd, 0x4c, 0x86, 0x01, 0xb7, 0xdf },
        { 0x08, 0x9b, 0xe2, 0x07, 0xb5, 0x44, 0xf1, 0xe4 },
        { 0x34, 0x53, 0x1c, 0xa7, 0x16, 0x8b, 0x8f, 0x38 },
        { 0xa0, 0xa0, 0xfe, 0x4d, 0x11, 0x27, 0xae, 0x93 } };

    funcName = "FNV-64";
    selected = FNV64selected;
/* test error checks */
    Terr = 0;
    TestR ( "init1", fnvSuccess, FNV64init (&amp;e64Context) );
    CommonTest();
    TestInit (FNV64init, e64Context, FNV64context)
    TestInitBasis (FNV64initBasis, e64Context, FNV64context)
    e64Context.Computed = FNVclobber+FNV64state;
    TestBlockin (FNV64blockin, e64Context, FNV64context)
    TestStringin (FNV64stringin, e64Context, FNV64context)
    TestFilein (FNV64filein, e64Context, FNV64context)
    TestResult (FNV64result, e64Context, FNV64context)
    ErrTestReport ();
/* test actual results */
    Terr = 0;
    BasisZero(FNV64stringBasis,FNV64size,FNV64svalues)
    for ( i = 0; i &lt; NTstrings; ++i ) {
        TestSTRBLKHash ( FNV64string, FNV64block,
                         FNV64svalues, FNV64bvalues, FNV64size )
/* try testing the incremental stuff */
        IncrHash(FNV64init,e64Context,FNV64blockin,FNV64result,
            FNV64initBasis,FNV64stringin,FNV64size,FNV64svalues)
/* now try testing file hash */
        TestFILEHash(FNV64file,FNV64svalues,FNV64size)
    }
    ValueTestReport ();
}   /* end Test64 */
#endif /* FNV_64bitIntegers */

//****************************************************************
//  Code for testing FNV128
//****************************************************************
void Test128 ( void ) {
    int i, err;
    long int iLen;
    uint8_t FNV128svalues[NTstrings][FNV128size] = {
        { 0x6c, 0x62, 0x27, 0x2e, 0x07, 0xbb, 0x01, 0x42,
          0x62, 0xb8, 0x21, 0x75, 0x62, 0x95, 0xc5, 0x8d },
        { 0xd2, 0x28, 0xcb, 0x69, 0x6f, 0x1a, 0x8c, 0xaf,
          0x78, 0x91, 0x2b, 0x70, 0x4e, 0x4a, 0x89, 0x64 },
        { 0x34, 0x3e, 0x16, 0x62, 0x79, 0x3c, 0x64, 0xbf,
          0x6f, 0x0d, 0x35, 0x97, 0xba, 0x44, 0x6f, 0x18 },
        { 0x74, 0x20, 0x2c, 0x60, 0x0b, 0x05, 0x1c, 0x16,
          0x5b, 0x1a, 0xca, 0xfe, 0xd1, 0x0d, 0x14, 0x19 } };
    uint8_t FNV128bvalues[NTstrings][FNV128size] = {
        { 0xd2, 0x28, 0xcb, 0x69, 0x10, 0x1a, 0x8c, 0xaf,
          0x78, 0x91, 0x2b, 0x70, 0x4e, 0x4a, 0x14, 0x7f },
        { 0x08, 0x80, 0x95, 0x45, 0x19, 0xab, 0x1b, 0xe9,
          0x5a, 0xa0, 0x73, 0x30, 0x55, 0xb7, 0x0e, 0x0c },
        { 0xe0, 0x1f, 0xcf, 0x9a, 0x45, 0x4f, 0xf7, 0x8d,
          0xa5, 0x40, 0xf1, 0xb2, 0x32, 0x34, 0xb2, 0x88 },
        { 0xe2, 0x67, 0xa7, 0x41, 0xa8, 0x49, 0x8f, 0x82,
          0x19, 0xf7, 0xc7, 0x8b, 0x3b, 0x17, 0xba, 0xc3 } };

    funcName = "FNV-128";
    selected = FNV128selected;
/* test error checks */
    Terr = 0;
    TestInit (FNV128init, e128Context, FNV128context)
    TestInitBasis (FNV128initBasis, e128Context, FNV128context)
    CommonTest();
    e128Context.Computed = FNVclobber+FNV128state;
    TestBlockin (FNV128blockin, e128Context, FNV128context)
    TestStringin (FNV128stringin, e128Context, FNV128context)
    TestFilein (FNV128filein, e128Context, FNV128context)
    TestResult (FNV128result, e128Context, FNV128context)
    ErrTestReport ();
/* test actual results */
    Terr = 0;
    BasisZero(FNV128stringBasis,FNV128size,FNV128svalues)
    for ( i = 0; i &lt; NTstrings; ++i ) {
        TestSTRBLKHash ( FNV128string, FNV128block,
                         FNV128svalues, FNV128bvalues, FNV128size )
/* try testing the incremental stuff */
        IncrHash(FNV128init,e128Context,FNV128blockin,FNV128result,
            FNV128initBasis,FNV128stringin,FNV128size,FNV128svalues)
/* now try testing file hash */
    TestFILEHash(FNV128file,FNV128svalues,FNV128size)
    }
    ValueTestReport ();
}    /* end Test128 */

//****************************************************************
//  Code for testing FNV256
//****************************************************************
void Test256 ( void ) {
    int i, err;
    long int iLen;
    uint8_t FNV256svalues[NTstrings][FNV256size] = {
        { 0xdd, 0x26, 0x8d, 0xbc, 0xaa, 0xc5, 0x50, 0x36,
          0x2d, 0x98, 0xc3, 0x84, 0xc4, 0xe5, 0x76, 0xcc,
          0xc8, 0xb1, 0x53, 0x68, 0x47, 0xb6, 0xbb, 0xb3,
          0x10, 0x23, 0xb4, 0xc8, 0xca, 0xee, 0x05, 0x35 },
        { 0x63, 0x32, 0x3f, 0xb0, 0xf3, 0x53, 0x03, 0xec,
          0x28, 0xdc, 0x75, 0x1d, 0x0a, 0x33, 0xbd, 0xfa,
          0x4d, 0xe6, 0xa9, 0x9b, 0x72, 0x66, 0x49, 0x4f,
          0x61, 0x83, 0xb2, 0x71, 0x68, 0x11, 0x63, 0x7c },
        { 0xb0, 0x55, 0xea, 0x2f, 0x30, 0x6c, 0xad, 0xad,
          0x4f, 0x0f, 0x81, 0xc0, 0x2d, 0x38, 0x89, 0xdc,
          0x32, 0x45, 0x3d, 0xad, 0x5a, 0xe3, 0x5b, 0x75,
          0x3b, 0xa1, 0xa9, 0x10, 0x84, 0xaf, 0x34, 0x28 },
        { 0x0c, 0x5a, 0x44, 0x40, 0x2c, 0x65, 0x38, 0xcf,
          0x98, 0xef, 0x20, 0xc4, 0x03, 0xa8, 0x0f, 0x65,
          0x9b, 0x80, 0xc9, 0xa5, 0xb0, 0x1a, 0x6a, 0x87,
          0x34, 0x2e, 0x26, 0x72, 0x64, 0x45, 0x67, 0xb1 } };
    uint8_t FNV256bvalues[NTstrings][FNV256size] = {
        { 0x63, 0x32, 0x3f, 0xb0, 0xf3, 0x53, 0x03, 0xec,
          0x28, 0xdc, 0x56, 0x1d, 0x0a, 0x33, 0xbd, 0xfa,
          0x4d, 0xe6, 0xa9, 0x9b, 0x72, 0x66, 0x49, 0x4f,
          0x61, 0x83, 0xb2, 0x71, 0x68, 0x11, 0x38, 0x7f },
        { 0xf4, 0xf7, 0xa1, 0xc2, 0xef, 0xd0, 0xe1, 0xe4,
          0xbb, 0x19, 0xe3, 0x45, 0x25, 0xc0, 0x72, 0x1a,
          0x06, 0xdd, 0x32, 0x8f, 0xa3, 0xd7, 0xa9, 0x14,
          0x39, 0xa0, 0x73, 0x43, 0x50, 0x1c, 0xf4, 0xf4 },
        { 0x6a, 0x7f, 0x34, 0xab, 0xc8, 0x5d, 0xe7, 0xd9,
          0x51, 0xb5, 0x15, 0x7e, 0xb5, 0x67, 0x2c, 0x59,
          0xb6, 0x04, 0x87, 0x65, 0x09, 0x47, 0xd3, 0x91,
          0xb1, 0x2d, 0x71, 0xe7, 0xfe, 0xf5, 0x53, 0x78 },
        { 0x3b, 0x97, 0x2c, 0x31, 0xbe, 0x84, 0x3a, 0x45,
          0x59, 0x02, 0x20, 0xd1, 0x12, 0x0d, 0x59, 0xe6,
          0xa3, 0x97, 0xa0, 0xc3, 0x34, 0xa1, 0xb9, 0x7d,
          0x5b, 0xff, 0x50, 0xa1, 0x0c, 0x3e, 0xca, 0x73 } };

    funcName = "FNV-256";
    selected = FNV256selected;
/* test error checks */
    Terr = 0;
    TestInit (FNV256init, e256Context, FNV256context)
    TestInitBasis (FNV256initBasis, e256Context, FNV256context)
    CommonTest();
    e256Context.Computed = FNVclobber+FNV256state;
    TestBlockin (FNV256blockin, e256Context, FNV256context)
    TestStringin (FNV256stringin, e256Context, FNV256context)
    TestFilein (FNV256filein, e256Context, FNV256context)
    TestResult (FNV256result, e256Context, FNV256context)
    ErrTestReport ();
/* test actual results */
    Terr = 0;
    BasisZero(FNV256stringBasis,FNV256size,FNV256svalues)
    for ( i = 0; i &lt; NTstrings; ++i ) {
        TestSTRBLKHash ( FNV256string, FNV256block,
                         FNV256svalues, FNV256bvalues, FNV256size )
/* try testing the incremental stuff */
        IncrHash(FNV256init,e256Context,FNV256blockin,FNV256result,
            FNV256initBasis,FNV256stringin,FNV256size,FNV256svalues)
/* now try testing file hash */
        TestFILEHash(FNV256file,FNV256svalues,FNV256size)
   }
    ValueTestReport ();
}    /* end Test256 */

//****************************************************************
//  Code for testing FNV512
//****************************************************************
void Test512 ( void ) {
    int i, err;
    long int iLen;
    uint8_t FNV512svalues[NTstrings][FNV512size] = {
        { 0xb8, 0x6d, 0xb0, 0xb1, 0x17, 0x1f, 0x44, 0x16,
          0xdc, 0xa1, 0xe5, 0x0f, 0x30, 0x99, 0x90, 0xac,
          0xac, 0x87, 0xd0, 0x59, 0xc9, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x21,
          0xe9, 0x48, 0xf6, 0x8a, 0x34, 0xc1, 0x92, 0xf6,
          0x2e, 0xa7, 0x9b, 0xc9, 0x42, 0xdb, 0xe7, 0xce,
          0x18, 0x20, 0x36, 0x41, 0x5f, 0x56, 0xe3, 0x4b,
          0xac, 0x98, 0x2a, 0xac, 0x4a, 0xfe, 0x9f, 0xd9 },
        { 0xe4, 0x3a, 0x99, 0x2d, 0xc8, 0xfc, 0x5a, 0xd7,
          0xde, 0x49, 0x3e, 0x3d, 0x69, 0x6d, 0x6f, 0x85,
          0xd6, 0x43, 0x26, 0xec, 0x07, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x98, 0x6f,
          0x90, 0xc2, 0x53, 0x2c, 0xaf, 0x5b, 0xe7, 0xd8,
          0x82, 0x91, 0xba, 0xa8, 0x94, 0xa3, 0x95, 0x22,
          0x53, 0x28, 0xb1, 0x96, 0xbd, 0x6a, 0x8a, 0x64,
          0x3f, 0xe1, 0x2c, 0xd8, 0x7b, 0x27, 0xff, 0x88 },
        { 0xb0, 0xec, 0x73, 0x8d, 0x9c, 0x6f, 0xd9, 0x69,
          0xd0, 0x5f, 0x0b, 0x35, 0xf6, 0xc0, 0xed, 0x53,
          0xad, 0xca, 0xcc, 0xcd, 0x8e, 0x00, 0x00, 0x00,
          0x4b, 0xf9, 0x9f, 0x58, 0xee, 0x41, 0x96, 0xaf,
          0xb9, 0x70, 0x0e, 0x20, 0x11, 0x08, 0x30, 0xfe,
          0xa5, 0x39, 0x6b, 0x76, 0x28, 0x0e, 0x47, 0xfd,
          0x02, 0x2b, 0x6e, 0x81, 0x33, 0x1c, 0xa1, 0xa9,
          0xce, 0xd7, 0x29, 0xc3, 0x64, 0xbe, 0x77, 0x88 },
        { 0x4f, 0xdf, 0x00, 0xec, 0xb9, 0xbc, 0x04, 0xdd,
          0x19, 0x38, 0x61, 0x8f, 0xe5, 0xc4, 0xfb, 0xb8,
          0x80, 0xa8, 0x2b, 0x15, 0xf5, 0xb6, 0xbd, 0x72,
          0x1e, 0xc2, 0xea, 0xfe, 0x03, 0xc4, 0x62, 0x48,
          0xf7, 0xa6, 0xc2, 0x47, 0x89, 0x92, 0x80, 0xd6,
          0xd2, 0xf4, 0x2f, 0xf6, 0xb4, 0x7b, 0xf2, 0x20,
          0x79, 0xdf, 0xd4, 0xbf, 0xe8, 0x7b, 0xf0, 0xbb,
          0x4e, 0x71, 0xea, 0xcb, 0x1e, 0x28, 0x77, 0x35 } };
    uint8_t FNV512bvalues[NTstrings][FNV512size] = {
        { 0xe4, 0x3a, 0x99, 0x2d, 0xc8, 0xfc, 0x5a, 0xd7,
          0xde, 0x49, 0x3e, 0x3d, 0x69, 0x6d, 0x6f, 0x85,
          0xd6, 0x43, 0x26, 0xec, 0x28, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x98, 0x6f,
          0x90, 0xc2, 0x53, 0x2c, 0xaf, 0x5b, 0xe7, 0xd8,
          0x82, 0x91, 0xba, 0xa8, 0x94, 0xa3, 0x95, 0x22,
          0x53, 0x28, 0xb1, 0x96, 0xbd, 0x6a, 0x8a, 0x64,
          0x3f, 0xe1, 0x2c, 0xd8, 0x7b, 0x28, 0x2b, 0xbf },
        { 0x73, 0x17, 0xdf, 0xed, 0x6c, 0x70, 0xdf, 0xec,
          0x6a, 0xdf, 0xce, 0xd2, 0xa5, 0xe0, 0x4d, 0x7e,
          0xec, 0x74, 0x4e, 0x3c, 0xe9, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x17, 0x93, 0x3d, 0x7a,
          0xf4, 0x5d, 0x70, 0xde, 0xf4, 0x23, 0xa3, 0x16,
          0xf1, 0x41, 0x17, 0xdf, 0x27, 0x2c, 0xd0, 0xfd,
          0x6b, 0x85, 0xf0, 0xf7, 0xc9, 0xbf, 0x6c, 0x51,
          0x96, 0xb3, 0x16, 0x0d, 0x02, 0x97, 0x5f, 0x38 },
        { 0x82, 0xf6, 0xe1, 0x04, 0x96, 0xde, 0x78, 0x34,
          0xb0, 0x8b, 0x21, 0xef, 0x46, 0x4c, 0xd2, 0x47,
          0x9e, 0x1d, 0x25, 0xe0, 0xca, 0x00, 0x00, 0x65,
          0xcb, 0x74, 0x80, 0x27, 0x39, 0xe0, 0xe5, 0x71,
          0x75, 0x22, 0xec, 0xf6, 0xd1, 0xf9, 0xa5, 0x2f,
          0x5f, 0xee, 0xfb, 0x4f, 0xab, 0x22, 0x73, 0xfd,
          0xe8, 0x31, 0x0f, 0x1b, 0x7b, 0x5c, 0x9a, 0x84,
          0x22, 0x48, 0xf4, 0xcb, 0xfb, 0x32, 0x27, 0x38 },
        { 0xfa, 0x7e, 0xb9, 0x1e, 0xfb, 0x64, 0x64, 0x11,
          0x8a, 0x73, 0x33, 0xbd, 0x96, 0x3b, 0xb6, 0x1f,
          0x2c, 0x6f, 0xe2, 0xe3, 0x6c, 0xd7, 0xd3, 0xe7,
          0x37, 0x28, 0xda, 0x57, 0x0c, 0x1f, 0xaf, 0xc3,
          0xd0, 0x6e, 0x4d, 0xd9, 0x53, 0x4a, 0x9f, 0xd4,
          0xa5, 0x2c, 0x43, 0x8b, 0xd2, 0x11, 0x69, 0x83,
          0x4a, 0xe6, 0x0d, 0x20, 0x7e, 0x0f, 0x8a, 0xf6,
          0x1a, 0xa1, 0x96, 0x25, 0x68, 0x37, 0xb8, 0x03 } };

    funcName = "FNV-512";
    selected = FNV512selected;
/* test error checks */
    Terr = 0;
    TestInit (FNV512init, e512Context, FNV512context)
    TestInitBasis (FNV512initBasis, e512Context, FNV512context)
    CommonTest();
    e512Context.Computed = FNVclobber+FNV512state;
    TestBlockin (FNV512blockin, e512Context, FNV512context)
    TestStringin (FNV512stringin, e512Context, FNV512context)
    TestFilein (FNV512filein, e512Context, FNV512context)
    TestResult (FNV512result, e512Context, FNV512context)
    ErrTestReport ();
/* test actual results */
    Terr = 0;
    BasisZero(FNV512stringBasis,FNV512size,FNV512svalues)
    for ( i = 0; i &lt; NTstrings; ++i ) {
        TestSTRBLKHash ( FNV512string, FNV512block,
                         FNV512svalues, FNV512bvalues, FNV512size )
/* try testing the incremental stuff */
        IncrHash(FNV512init,e512Context,FNV512blockin,FNV512result,
            FNV512initBasis,FNV512stringin,FNV512size,FNV512svalues)
/* now try testing file hash */
        TestFILEHash(FNV512file,FNV512svalues,FNV512size)
    }
    ValueTestReport ();
}    /* end Test512 */

//****************************************************************
//  Code for testing FNV1024
//****************************************************************
void Test1024 ( void ) {
    uint8_t FNV1024svalues[NTstrings][FNV1024size] = {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x5f, 0x7a, 0x76, 0x75, 0x8e, 0xcc, 0x4d,
        0x32, 0xe5, 0x6d, 0x5a, 0x59, 0x10, 0x28, 0xb7,
        0x4b, 0x29, 0xfc, 0x42, 0x23, 0xfd, 0xad, 0xa1,
        0x6c, 0x3b, 0xf3, 0x4e, 0xda, 0x36, 0x74, 0xda,
        0x9a, 0x21, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xc6, 0xd7,
        0xeb, 0x6e, 0x73, 0x80, 0x27, 0x34, 0x51, 0x0a,
        0x55, 0x5f, 0x25, 0x6c, 0xc0, 0x05, 0xae, 0x55,
        0x6b, 0xde, 0x8c, 0xc9, 0xc6, 0xa9, 0x3b, 0x21,
        0xaf, 0xf4, 0xb1, 0x6c, 0x71, 0xee, 0x90, 0xb3 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x98, 0xd7, 0xc1, 0x9f, 0xbc, 0xe6, 0x53, 0xdf,
        0x22, 0x1b, 0x9f, 0x71, 0x7d, 0x34, 0x90, 0xff,
        0x95, 0xca, 0x87, 0xfd, 0xae, 0xf3, 0x0d, 0x1b,
        0x82, 0x33, 0x72, 0xf8, 0x5b, 0x24, 0xa3, 0x72,
        0xf5, 0x0e, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x07, 0x68, 0x5c, 0xd8,
        0x1a, 0x49, 0x1d, 0xbc, 0xcc, 0x21, 0xad, 0x06,
        0x64, 0x8d, 0x09, 0xa5, 0xc8, 0xcf, 0x5a, 0x78,
        0x48, 0x20, 0x54, 0xe9, 0x14, 0x70, 0xb3, 0x3d,
        0xde, 0x77, 0x25, 0x2c, 0xae, 0xf6, 0x95, 0xaa },
      { 0x00, 0x00, 0x06, 0x31, 0x17, 0x5f, 0xa7, 0xae,
        0x64, 0x3a, 0xd0, 0x87, 0x23, 0xd3, 0x12, 0xc9,
        0xfd, 0x02, 0x4a, 0xdb, 0x91, 0xf7, 0x7f, 0x6b,
        0x19, 0x58, 0x71, 0x97, 0xa2, 0x2b, 0xcd, 0xf2,
        0x37, 0x27, 0x16, 0x6c, 0x45, 0x72, 0xd0, 0xb9,
        0x85, 0xd5, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,
        0x70, 0xd1, 0x1e, 0xf4, 0x18, 0xef, 0x08, 0xb8,
        0xa4, 0x9e, 0x1e, 0x82, 0x5e, 0x54, 0x7e, 0xb3,
        0x99, 0x37, 0xf8, 0x19, 0x22, 0x2f, 0x3b, 0x7f,
        0xc9, 0x2a, 0x0e, 0x47, 0x07, 0x90, 0x08, 0x88,
        0x84, 0x7a, 0x55, 0x4b, 0xac, 0xec, 0x98, 0xb0 },
      { 0xf6, 0xf7, 0x47, 0xaf, 0x25, 0xa9, 0xde, 0x26,
        0xe8, 0xa4, 0x93, 0x43, 0x1e, 0x31, 0xb4, 0xa1,
        0xed, 0x2a, 0x92, 0x30, 0x4a, 0xf6, 0xca, 0x97,
        0x6b, 0xc1, 0xd9, 0x6f, 0xfc, 0xad, 0x35, 0x24,
        0x4e, 0x8d, 0x38, 0x5d, 0x55, 0xf4, 0x2f, 0xdc,
        0xc8, 0xf2, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xf7, 0xca, 0x87, 0xce,
        0x43, 0x22, 0x7b, 0x98, 0xc1, 0x44, 0x60, 0x7e,
        0x67, 0xcc, 0x50, 0xaf, 0x99, 0xbc, 0xc5, 0xd1,
        0x51, 0x4b, 0xb0, 0xd9, 0x23, 0xee, 0xde, 0xdd,
        0x69, 0xe8, 0xe7, 0x47, 0x02, 0x05, 0x08, 0x3a,
        0x0c, 0x02, 0x27, 0xd0, 0xcc, 0x69, 0xde, 0x23 } };
    uint8_t FNV1024bvalues[NTstrings][FNV1024size] = {
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x98, 0xd7, 0xc1, 0x9f, 0xbc, 0xe6, 0x53, 0xdf,
        0x22, 0x1b, 0x9f, 0x71, 0x7d, 0x34, 0x90, 0xff,
        0x95, 0xca, 0x87, 0xfd, 0xae, 0xf3, 0x0d, 0x1b,
        0x82, 0x33, 0x72, 0xf8, 0x5b, 0x24, 0xa3, 0x72,
        0xf5, 0x0e, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x07, 0x68, 0x5c, 0xd8,
        0x1a, 0x49, 0x1d, 0xbc, 0xcc, 0x21, 0xad, 0x06,
        0x64, 0x8d, 0x09, 0xa5, 0xc8, 0xcf, 0x5a, 0x78,
        0x48, 0x20, 0x54, 0xe9, 0x14, 0x70, 0xb3, 0x3d,
        0xde, 0x77, 0x25, 0x2c, 0xae, 0xf6, 0x65, 0x97 },
      { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4,
        0x6e, 0xf4, 0x1c, 0xd2, 0x3a, 0x4d, 0xcd, 0xd4,
        0x06, 0x83, 0x49, 0x63, 0xb7, 0x8e, 0x82, 0x24,
        0x1a, 0x6f, 0x5c, 0xb0, 0x6f, 0x40, 0x3c, 0xbd,
        0x5a, 0x7c, 0x89, 0x03, 0xce, 0xf6, 0xa5, 0xf4,
        0xfd, 0xd2, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x0b, 0x7c, 0xd7, 0xfb, 0x20,
        0xc3, 0x63, 0x1d, 0xc8, 0x90, 0x39, 0x52, 0xe9,
        0xee, 0xb7, 0xf6, 0x18, 0x69, 0x8f, 0x4c, 0x87,
        0xda, 0x23, 0xad, 0x74, 0xb2, 0xc5, 0xf6, 0xf1,
        0xfe, 0xc4, 0xa6, 0x4b, 0x54, 0x66, 0x18, 0xa2 },
      { 0x00, 0x09, 0xdc, 0x92, 0x10, 0x75, 0xfd, 0x8a,
        0x5e, 0x3e, 0x1a, 0x37, 0x2c, 0x72, 0xa5, 0x9b,
        0xb1, 0x0c, 0xca, 0x1a, 0x94, 0xc8, 0xb2, 0x38,
        0x7d, 0x63, 0xa7, 0xef, 0xa7, 0xfc, 0xa7, 0xa7,
        0x17, 0xa6, 0x4e, 0x6c, 0x2d, 0x62, 0xfb, 0x61,
        0x78, 0xf7, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x08,
        0xf4, 0x4d, 0x00, 0x8a, 0xaa, 0xb0, 0x86, 0x57,
        0x49, 0x35, 0x50, 0x2c, 0x49, 0x08, 0x7c, 0x84,
        0x9b, 0xcb, 0xbe, 0xfa, 0x03, 0x3f, 0x45, 0x2a,
        0xf6, 0x38, 0x24, 0x26, 0xba, 0x5d, 0x3b, 0xb5,
        0x71, 0xb6, 0x46, 0x5b, 0x2a, 0xe8, 0xc8, 0xf0 },
      { 0xc8, 0x01, 0xf8, 0xe0, 0x8a, 0xe9, 0x1b, 0x18,
        0x0b, 0x98, 0xdd, 0x7d, 0x9f, 0x65, 0xce, 0xb6,
        0x87, 0xca, 0x86, 0x35, 0x8c, 0x69, 0x05, 0xf6,
        0x0a, 0x7d, 0x10, 0x14, 0xc1, 0x82, 0xb0, 0x4f,
        0xd6, 0x08, 0xa2, 0xca, 0x4d, 0xd6, 0x0a, 0x30,
        0x0a, 0x15, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x80, 0x45, 0x14, 0x9a, 0xde,
        0x1c, 0x79, 0xab, 0xe3, 0xb7, 0x09, 0xa4, 0x06,
        0xf7, 0xd9, 0x20, 0x51, 0x69, 0xbe, 0xc5, 0x9b,
        0x12, 0x61, 0x40, 0xbc, 0xb9, 0x6f, 0x9d, 0x5d,
        0x3e, 0x2e, 0xa9, 0x1e, 0x21, 0xcd, 0xc2, 0x04,
        0x9f, 0x57, 0xbe, 0xcd, 0x00, 0x2d, 0x7c, 0x47 } };
    long int iLen;
    int i, err;

    funcName = "FNV-1024";
    selected = FNV1024selected;
    /* test error checks */
    Terr = 0;
    TestInit (FNV1024init, e1024Context, FNV1024context)
    TestInitBasis (FNV1024initBasis, e1024Context, FNV1024context)
    CommonTest();
    e1024Context.Computed = FNVclobber+FNV1024state;
    TestBlockin (FNV1024blockin, e1024Context, FNV1024context)
    TestStringin (FNV1024stringin, e1024Context, FNV1024context)
    TestFilein (FNV1024filein, e1024Context, FNV1024context)
    TestResult (FNV1024result, e1024Context, FNV1024context)
    ErrTestReport ();
/* test actual results */
    Terr = 0;
    BasisZero(FNV1024stringBasis,FNV1024size,FNV1024svalues)
    for ( i = 0; i &lt; NTstrings; ++i ) {
        TestSTRBLKHash ( FNV1024string, FNV1024block,
                         FNV1024svalues, FNV1024bvalues,
                                     FNV1024size )
/* try testing the incremental stuff */
        IncrHash(FNV1024init,e1024Context,FNV1024blockin,
                 FNV1024result, FNV1024initBasis,
                 FNV1024stringin,FNV1024size,FNV1024svalues)
/* now try testing file hash */
        TestFILEHash(FNV1024file,FNV1024svalues,FNV1024size)
    }
    ValueTestReport ();
}    /* end Test1024 */


&lt;CODE ENDS&gt;</pre><a href="#section-8.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="sec-8.4">
<section id="section-8.4">
        <h3 id="name-makefile">
<a href="#section-8.4" class="section-number selfRef">8.4. </a><a href="#name-makefile" class="section-name selfRef">Makefile</a>
        </h3>
<p id="section-8.4-1">Below is a simple makefile to produce and run the test program or
  to provide a library with all the FNV functions supplied in it.<a href="#section-8.4-1" class="pilcrow">¶</a></p>
<p id="section-8.4-2">WARNING: When actually using the following as a makefile, the
  five-character sequence "&lt;TAB&gt;" must be changed to a tab (0x09)
  character!<a href="#section-8.4-2" class="pilcrow">¶</a></p>
<div class="lang-makefile sourcecode" id="section-8.4-3">
<pre>&lt;CODE BEGINS&gt; file "makefile"

# Makefile for fnv
# If you extract this file from RFC 9923, the five-character sequence
#     &lt;TAB&gt; below must be replaced with a tab (0x09) character.

explanation:
&lt;TAB&gt;@echo Choose one of the following make targets:
&lt;TAB&gt;@echo make FNVhash -- test program
&lt;TAB&gt;@echo make libfnv.a -- library you can use
&lt;TAB&gt;@echo make clean -- removes all of the built targets

SRC=FNV32.c FNV64.c FNV128.c FNV256.c FNV512.c FNV1024.c
HDR=FNV32.h FNV64.h FNV128.h FNV256.h FNV512.h FNV1024.h \
&lt;TAB&gt;FNVconfig.h FNVErrorCodes.h fnv-private.h
OBJ=$(SRC:.c=.o)
CFLAGS=-Wall
AR=ar
ARFLAGS= rcs

FNVhash: libfnv.a main.c
&lt;TAB&gt;$(CC) $(CFLAGS) -o FNVhash main.c libfnv.a

libfnv.a: $(SRC) $(HDR)
&lt;TAB&gt;rm -f libfnv.a *.o
&lt;TAB&gt;$(CC) $(CFLAGS) -c $(SRC)
&lt;TAB&gt;$(AR) $(ARFLAGS) libfnv.a $(OBJ)

clean:
&lt;TAB&gt;rm -rf libfnv.a FNVhash *.o

&lt;CODE ENDS&gt;</pre><a href="#section-8.4-3" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="iana">
<section id="section-9">
      <h2 id="name-iana-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-9-1">This document has no IANA actions.<a href="#section-9-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-10">
      <h2 id="name-references">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-10.1">
        <h3 id="name-normative-references">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="C">[C]</dt>
        <dd>
<span class="refAuthor">Kernighan, B. W.</span> and <span class="refAuthor">D. M. Ritchie</span>, <span class="refTitle">"The C Programming Language, 2nd Edition"</span>, <span class="seriesInfo">ISBN-10 0-13-110362-8</span>, <span class="seriesInfo">ISBN-13 978-0131103627</span>, <time datetime="1988" class="refDate">1988</time>. </dd>
<dd class="break"></dd>
<dt id="RFC0020">[RFC0020]</dt>
        <dd>
<span class="refAuthor">Cerf, V.</span>, <span class="refTitle">"ASCII format for network interchange"</span>, <span class="seriesInfo">STD 80</span>, <span class="seriesInfo">RFC 20</span>, <span class="seriesInfo">DOI 10.17487/RFC0020</span>, <time datetime="1969-10" class="refDate">October 1969</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-10.2">
        <h3 id="name-informative-references">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="BASIC">[BASIC]</dt>
        <dd>
<span class="refAuthor">Diamond, W.</span>, <span class="refTitle">"FNV32 PowerBASIC inline x86 assembler"</span>, <span>&lt;<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html#PowerBASIC">http://www.isthe.com/chongo/tech/comp/fnv/index.html#PowerBASIC</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BFDseq">[BFDseq]</dt>
        <dd>
<span class="refAuthor">Jethanandani, M.</span>, <span class="refAuthor">Agarwal, S.</span>, <span class="refAuthor">Mishra, A.</span>, <span class="refAuthor">Saxena, A.</span>, and <span class="refAuthor">A. DeKok</span>, <span class="refTitle">"Secure BFD Sequence Numbers"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-bfd-secure-sequence-numbers-09</span>, <time datetime="2022-03-29" class="refDate">29 March 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-bfd-secure-sequence-numbers-09">https://datatracker.ietf.org/doc/html/draft-ietf-bfd-secure-sequence-numbers-09</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="calc">[calc]</dt>
        <dd>
<span class="refAuthor">Bell, D.</span> and <span class="refAuthor">L. Noll</span>, <span class="refTitle">"Calc - C-style arbitrary precision calculator"</span>, <span>&lt;<a href="http://www.isthe.com/chongo/tech/comp/calc/index.html">http://www.isthe.com/chongo/tech/comp/calc/index.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="deliantra">[deliantra]</dt>
        <dd>
<span class="refAuthor">The Deliantra Team</span>, <span class="refTitle">"Deliantra MMORPG"</span>, <time datetime="2022-10-16" class="refDate">16 October 2022</time>, <span>&lt;<a href="http://www.deliantra.net/">http://www.deliantra.net/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="fasmlab">[fasmlab]</dt>
        <dd>
<span class="refAuthor">Fasmlab</span>, <span class="refTitle">"Integrated Development Environments"</span>, <span>&lt;<a href="https://sourceforge.net/projects/fasmlab/">https://sourceforge.net/projects/fasmlab/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="FIPS202">[FIPS202]</dt>
        <dd>
<span class="refAuthor">NIST</span>, <span class="refTitle">"SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions"</span>, <span class="seriesInfo">FIPS PUB 202</span>, <span class="seriesInfo">DOI 10.6028/NIST.FIPS.202</span>, <time datetime="2015-08" class="refDate">August 2015</time>, <span>&lt;<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="flatassembler">[flatassembler]</dt>
        <dd>
<span class="refAuthor">Grysztar, T.</span>, <span class="refTitle">"flat assembler: Assembly language resources"</span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://flatassembler.net/">https://flatassembler.net/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="FNV">[FNV]</dt>
        <dd>
<span class="refAuthor">Fowler, G.</span>, <span class="refAuthor">Noll, L.</span>, and <span class="refAuthor">K. Vo</span>, <span class="refTitle">"FNV (Fowler/Noll/Vo)"</span>, <span>&lt;<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">http://www.isthe.com/chongo/tech/comp/fnv/index.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Fortran">[Fortran]</dt>
        <dd>
<span class="refAuthor">Fortran Standard Library</span>, <span class="refTitle">"A community driven standard library for (modern) Fortran"</span>, <span>&lt;<a href="https://stdlib.fortran-lang.org/">https://stdlib.fortran-lang.org/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="FragCache">[FragCache]</dt>
        <dd>
<span class="refAuthor">Weaver, E.</span>, <span class="refTitle">"Improving Running Components at Twitter"</span>, <span class="refContent">Slide 31</span>, <time datetime="2009" class="refDate">2009</time>, <span>&lt;<a href="https://www.slideshare.net/slideshow/improving-running-components-at-twitter/1141786">https://www.slideshare.net/slideshow/improving-running-components-at-twitter/1141786</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="FreeBSD">[FreeBSD]</dt>
        <dd>
<span class="refAuthor">Baio, D. G.</span>, <span class="refTitle">"FreeBSD 4.3 Release Notes (Last modified on 21 February 2021)"</span>, <span class="refContent">The Free BSD Project</span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://www.freebsd.org/releases/4.3R/notes.html">https://www.freebsd.org/releases/4.3R/notes.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="FRET">[FRET]</dt>
        <dd>
<span class="refAuthor">McCarthy, M.</span>, <span class="refTitle">"FRET: helping understand file formats"</span>, <time datetime="2006-01-19" class="refDate">19 January 2006</time>, <span>&lt;<a href="https://fret.sourceforge.net/">https://fret.sourceforge.net/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE">[IEEE]</dt>
        <dd>
<span class="refAuthor">Institute for Electrical and Electronics Engineers</span>, <span class="refTitle">"IEEE website"</span>, <span>&lt;<a href="https://www.ieee.org/">https://www.ieee.org/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEEE8021Q-2022">[IEEE8021Q-2022]</dt>
        <dd>
<span class="refAuthor">IEEE</span>, <span class="refTitle">"IEEE Standard for Local and Metropolitan Area Networks--Bridges and Bridged Networks"</span>, <span class="seriesInfo">DOI 10.1109/IEEESTD.2022.10004498</span>, <span class="seriesInfo">IEEE Std 802.1Q-2022</span>, <time datetime="2022-12" class="refDate">December 2022</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/document/10004498">https://ieeexplore.ieee.org/document/10004498</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IEN137">[IEN137]</dt>
        <dd>
<span class="refAuthor">Cohen, D.</span>, <span class="refTitle">"On Holy Wars and A Plea For Peace"</span>, <span class="refContent">IEN 137</span>, <time datetime="1980-04-01" class="refDate">1 April 1980</time>, <span>&lt;<a href="https://www.rfc-editor.org/ien/ien137.txt">https://www.rfc-editor.org/ien/ien137.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IPv6flow">[IPv6flow]</dt>
        <dd>
<span class="refAuthor">Anderson, L.</span>, <span class="refAuthor">Brownlee, N.</span>, and <span class="refAuthor">B. E. Carpenter</span>, <span class="refTitle">"Comparing Hash Function Algorithms for the IPv6 Flow Label"</span>, <span class="refContent">University of Auckland Department of Computer Science Technical Report 2012-002</span>, <span class="seriesInfo">ISSN 1173-3500</span>, <time datetime="2012-03" class="refDate">March 2012</time>, <span>&lt;<a href="https://www.cs.auckland.ac.nz/~brian/flowhashRep.pdf">https://www.cs.auckland.ac.nz/~brian/flowhashRep.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LCN2">[LCN2]</dt>
        <dd>
<span class="refAuthor">Noll, L.</span> and <span class="refAuthor">C. Ferguson</span>, <span class="refTitle">"lcn2 / fnv"</span>, <span class="refContent">commit 953444c</span>, <time datetime="2025-11-19" class="refDate">19 November 2025</time>, <span>&lt;<a href="https://github.com/lcn2/fnv">https://github.com/lcn2/fnv</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Leprechaun">[Leprechaun]</dt>
        <dd>
<span class="refAuthor">Sanmayce project</span>, <span class="refTitle">"Sanmayce project 'Underdog Way'"</span>, <span>&lt;<a href="http://www.sanmayce.com/Downloads/">http://www.sanmayce.com/Downloads/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="libketama">[libketama]</dt>
        <dd>
<span class="refAuthor">Jones, R.</span>, <span class="refTitle">"libketama: Consistent Hashing library for memcached clients"</span>, <time datetime="2007-04-10" class="refDate">10 April 2007</time>, <span>&lt;<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients">https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="libsir">[libsir]</dt>
        <dd>
<span class="refAuthor">Lederman, R.</span> and <span class="refAuthor">J. Johnson</span>, <span class="refTitle">"libsir logging library"</span>, <span class="refContent">commit 0ae0173</span>, <time datetime="2025-12-03" class="refDate">3 December 2025</time>, <span>&lt;<a href="https://github.com/aremmell/libsir">https://github.com/aremmell/libsir</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="memcache">[memcache]</dt>
        <dd>
<span class="refAuthor">Dovgal, A.</span>, <span class="refAuthor">Joye, P.</span>, <span class="refAuthor">Radtke, H.</span>, <span class="refAuthor">Johansson, M.</span>, and <span class="refAuthor">T. Srnka</span>, <span class="refTitle">"PHP memcached extension"</span>, <time datetime="2023-04-30" class="refDate">30 April 2023</time>, <span>&lt;<a href="https://pecl.php.net/package/memcache">https://pecl.php.net/package/memcache</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="NCHF">[NCHF]</dt>
        <dd>
<div class="refInstance" id="NCHF1">
            <span class="refAuthor">Hayes, C.</span> and <span class="refAuthor">D. Malone</span>, <span class="refTitle">"Questioning the Criteria for Evaluating Non-Cryptographic Hash Functions"</span>, <span class="refContent">Communications of the ACM, Vol. 68 No. 2, pp. 46-51</span>, <span class="seriesInfo">DOI 10.1145/3704255</span>, <time datetime="2025-02" class="refDate">February 2025</time>, <span>&lt;<a href="https://cacm.acm.org/practice/questioning-the-criteria-for-evaluating-non-cryptographic-hash-functions/">https://cacm.acm.org/practice/questioning-the-criteria-for-evaluating-non-cryptographic-hash-functions/</a>&gt;</span>. </div>
<div class="refInstance" id="NCHF2">
            <span class="refAuthor">Hayes, C.</span> and <span class="refAuthor">D. Malone</span>, <span class="refTitle">"An Evaluation of FNV Non-Cryptographic Hash Functions"</span>, <span class="refContent">Proceedings of the 35th Irish Signals and Systems Conference (ISSC)</span>, <span class="seriesInfo">DOI 10.1109/ISSC61953.2024.10603139</span>, <time datetime="2024-06" class="refDate">June 2024</time>, <span>&lt;<a href="https://ieeexplore.ieee.org/abstract/document/10603139">https://ieeexplore.ieee.org/abstract/document/10603139</a>&gt;</span>. </div>
</dd>
<dd class="break"></dd>
<dt id="RFC3174">[RFC3174]</dt>
        <dd>
<span class="refAuthor">Eastlake 3rd, D.</span> and <span class="refAuthor">P. Jones</span>, <span class="refTitle">"US Secure Hash Algorithm 1 (SHA1)"</span>, <span class="seriesInfo">RFC 3174</span>, <span class="seriesInfo">DOI 10.17487/RFC3174</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3174">https://www.rfc-editor.org/info/rfc3174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6194">[RFC6194]</dt>
        <dd>
<span class="refAuthor">Polk, T.</span>, <span class="refAuthor">Chen, L.</span>, <span class="refAuthor">Turner, S.</span>, and <span class="refAuthor">P. Hoffman</span>, <span class="refTitle">"Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms"</span>, <span class="seriesInfo">RFC 6194</span>, <span class="seriesInfo">DOI 10.17487/RFC6194</span>, <time datetime="2011-03" class="refDate">March 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6194">https://www.rfc-editor.org/info/rfc6194</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6234">[RFC6234]</dt>
        <dd>
<span class="refAuthor">Eastlake 3rd, D.</span> and <span class="refAuthor">T. Hansen</span>, <span class="refTitle">"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)"</span>, <span class="seriesInfo">RFC 6234</span>, <span class="seriesInfo">DOI 10.17487/RFC6234</span>, <time datetime="2011-05" class="refDate">May 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6234">https://www.rfc-editor.org/info/rfc6234</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6437">[RFC6437]</dt>
        <dd>
<span class="refAuthor">Amante, S.</span>, <span class="refAuthor">Carpenter, B.</span>, <span class="refAuthor">Jiang, S.</span>, and <span class="refAuthor">J. Rajahalme</span>, <span class="refTitle">"IPv6 Flow Label Specification"</span>, <span class="seriesInfo">RFC 6437</span>, <span class="seriesInfo">DOI 10.17487/RFC6437</span>, <time datetime="2011-11" class="refDate">November 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6437">https://www.rfc-editor.org/info/rfc6437</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7357">[RFC7357]</dt>
        <dd>
<span class="refAuthor">Zhai, H.</span>, <span class="refAuthor">Hu, F.</span>, <span class="refAuthor">Perlman, R.</span>, <span class="refAuthor">Eastlake 3rd, D.</span>, and <span class="refAuthor">O. Stokes</span>, <span class="refTitle">"Transparent Interconnection of Lots of Links (TRILL): End Station Address Distribution Information (ESADI) Protocol"</span>, <span class="seriesInfo">RFC 7357</span>, <span class="seriesInfo">DOI 10.17487/RFC7357</span>, <time datetime="2014-09" class="refDate">September 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7357">https://www.rfc-editor.org/info/rfc7357</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7873">[RFC7873]</dt>
        <dd>
<span class="refAuthor">Eastlake 3rd, D.</span> and <span class="refAuthor">M. Andrews</span>, <span class="refTitle">"Domain Name System (DNS) Cookies"</span>, <span class="seriesInfo">RFC 7873</span>, <span class="seriesInfo">DOI 10.17487/RFC7873</span>, <time datetime="2016-05" class="refDate">May 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7873">https://www.rfc-editor.org/info/rfc7873</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8200">[RFC8200]</dt>
        <dd>
<span class="refAuthor">Deering, S.</span> and <span class="refAuthor">R. Hinden</span>, <span class="refTitle">"Internet Protocol, Version 6 (IPv6) Specification"</span>, <span class="seriesInfo">STD 86</span>, <span class="seriesInfo">RFC 8200</span>, <span class="seriesInfo">DOI 10.17487/RFC8200</span>, <time datetime="2017-07" class="refDate">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8200">https://www.rfc-editor.org/info/rfc8200</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RimStone">[RimStone]</dt>
        <dd>
<span class="refAuthor">Gliim LLC</span>, <span class="refTitle">"Golf Language Hash Tables"</span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://rimstone-lang.com/">https://rimstone-lang.com/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Smash">[Smash]</dt>
        <dd>
<span class="refAuthor">Emms, S.</span>, <span class="refTitle">"Smash - find duplicate files super fast"</span>, <time datetime="2024-12-08" class="refDate">8 December 2024</time>, <span>&lt;<a href="https://www.linuxlinks.com/smash-find-duplicate-files-super-fast/">https://www.linuxlinks.com/smash-find-duplicate-files-super-fast/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="twistylists">[twistylists]</dt>
      <dd>
<span class="refAuthor">Zethmayr, D.</span>, <span class="refTitle">"twistylists: A no-sort namespace engine; developers invited"</span>, <time datetime="2012-11-06" class="refDate">6 November 2012</time>, <span>&lt;<a href="https://twistylists.blogspot.com/">https://twistylists.blogspot.com/</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="Effort">
<section id="appendix-A">
      <h2 id="name-work-comparison-with-sha-1-">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-work-comparison-with-sha-1-" class="section-name selfRef">Work Comparison with SHA-1 and SHA-256</a>
      </h2>
<p id="appendix-A-1">This appendix provides a simplistic rough comparison of the level
of effort required to compute FNV-1a, SHA-1 <span>[<a href="#RFC3174" class="cite xref">RFC3174</a>]</span>, and SHA-256 <span>[<a href="#RFC6234" class="cite xref">RFC6234</a>]</span> for short
messages -- that is, those less than around 50 bytes. Some CPUs may have
special instructions or other hardware to accelerate certain
cryptographic operations, so if performance is particularly important
for an application, benchmarking on the target platform would be
appropriate.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">Ignoring transfer of control and conditional tests, and equating all
logical and arithmetic operations, FNV requires two operations per byte:
an XOR operation and a multiply operation.<a href="#appendix-A-2" class="pilcrow">¶</a></p>
<p id="appendix-A-3">SHA-1 and SHA-256 are actually designed to accept a bit vector
input, although almost all computer uses apply them to an integer
number of bytes. They both process blocks of 512 bits (64 bytes), and
we estimate the effort involved in processing a full block. There is
some overhead per message to indicate message termination and
size. Assuming that the message is an even number of bytes, this overhead
would be 9 bytes for SHA-1 and 17 bytes for SHA-256. So, assuming that the
message with that overhead fits into one block, the message would be
up to 55 bytes for SHA-1 or up to 47 bytes for SHA-256.<a href="#appendix-A-3" class="pilcrow">¶</a></p>
<p id="appendix-A-4">SHA-1 is a relatively weak cryptographic hash function producing a
160-bit hash. It has been substantially broken <span>[<a href="#RFC6194" class="cite xref">RFC6194</a>]</span>. Ignoring SHA-1's initial setup, transfer of
control, and conditional tests, but counting all logical and
arithmetic operations, including counting indexing as an addition,
SHA-1 requires 1,744 operations per 64-byte block or 31.07 operations
per byte for a message of 55 bytes. By this rough measure, it is a
little over 15.5 times the effort of FNV.<a href="#appendix-A-4" class="pilcrow">¶</a></p>
<p id="appendix-A-5">SHA-256 is, at the time of publication, considered to be a stronger
cryptographic hash function than SHA-1. Ignoring SHA-256's initial setup, transfer of control, and conditional tests, but counting all
logical and arithmetic operations, SHA-1 requires 2,058 operations per
64-byte block or 48.79 operations per byte for a message of 47
bytes. By this rough measure, it is over 24 times the effort of
FNV.<a href="#appendix-A-5" class="pilcrow">¶</a></p>
<p id="appendix-A-6">However, FNV is commonly used for short inputs, so doing a comparison of
such inputs is relevant. Using the above comparison method, for inputs
of N bytes, where N is &lt;= 55 so SHA-1 will take one block, the
ratio of the effort for SHA-1 to the effort for FNV will be 872/N.
For inputs of N bytes, where N is &lt;= 47 so SHA-256 will take one
block, the ratio of the effort for SHA-256 to the effort for FNV will
be 1029/N. Some examples are given below.<a href="#appendix-A-6" class="pilcrow">¶</a></p>
<table class="center" id="table-3">
        <caption><a href="#table-3" class="selfRef">Table 3</a></caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Example</th>
            <th class="text-right" rowspan="1" colspan="1">Length in Bytes</th>
            <th class="text-right" rowspan="1" colspan="1">SHA-1 Effort Relative to FNV Effort</th>
            <th class="text-right" rowspan="1" colspan="1">SHA-256 Effort Relative to FNV Effort</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">IPv4 address</td>
            <td class="text-right" rowspan="1" colspan="1">4</td>
            <td class="text-right" rowspan="1" colspan="1">218</td>
            <td class="text-right" rowspan="1" colspan="1">514</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">MAC address</td>
            <td class="text-right" rowspan="1" colspan="1">6</td>
            <td class="text-right" rowspan="1" colspan="1">145</td>
            <td class="text-right" rowspan="1" colspan="1">171</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">IPv6 address</td>
            <td class="text-right" rowspan="1" colspan="1">16</td>
            <td class="text-right" rowspan="1" colspan="1">54</td>
            <td class="text-right" rowspan="1" colspan="1">64</td>
          </tr>
        </tbody>
      </table>
</section>
</div>
<section id="appendix-B">
      <h2 id="name-previous-ietf-fnv-code">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-previous-ietf-fnv-code" class="section-name selfRef">Previous IETF FNV Code</a>
      </h2>
<p id="appendix-B-1">FNV-1a was referenced in draft-ietf-tls-cached-info-08
(which was ultimately published as RFC 7924, but RFC 7924 no longer contains the code below). Herein, we provide the Java code for FNV64 from that earlier draft, included with the kind permission of the author:<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<div class="lang-java sourcecode" id="appendix-B-2">
<pre>&lt;CODE BEGINS&gt;
 /*
 * Java code sample, implementing 64 bit FNV-1a
 * By Stefan Santesson
 */

import java.math.BigInteger;

public class FNV {

   static public BigInteger getFNV1a64Digest (String inpString) {

       BigInteger m = new BigInteger("2").pow(64);
       BigInteger fnvPrime = new BigInteger("1099511628211");
       BigInteger fnvOffsetBasis = new BigInteger
                                   ("14695981039346656037");

       BigInteger digest = fnvOffsetBasis;

       for (int i = 0; i &lt; inpString.length(); i++) {
           digest = digest.xor(BigInteger.valueOf(
                    (int) inpString.charAt(i)));
           digest = digest.multiply(fnvPrime).mod(m);
       }
       return (digest);

   }
}

&lt;CODE ENDS&gt;</pre><a href="#appendix-B-2" class="pilcrow">¶</a>
</div>
</section>
<div id="Acknowledgements">
<section id="appendix-C">
      <h2 id="name-acknowledgements">
<a href="#name-acknowledgements" class="section-name selfRef">Acknowledgements</a>
      </h2>
<p id="appendix-C-1">The authors greatly appreciate the work of <span class="contact-name">Glenn S. Fowler</span>, who was part of the team that created the FNV algorithm.<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<p id="appendix-C-2">The contributions of the following, listed in alphabetical order,
  are gratefully acknowledged:<a href="#appendix-C-2" class="pilcrow">¶</a></p>
<p id="appendix-C-3"><span class="contact-name">Roman Donchenko</span>, <span class="contact-name">Frank   Ellermann</span>, <span class="contact-name">Stephen Farrell</span>, <span class="contact-name">Tony   Finch</span>, <span class="contact-name">Paul Hoffman</span>, <span class="contact-name">Charlie Kaufman</span>, <span class="contact-name">Eliot   Lear</span>, <span class="contact-name">Bob Moskowitz</span>, <span class="contact-name">Gayle   Noble</span>, <span class="contact-name">Stefan Santesson</span>, <span class="contact-name">Mukund   Sivaraman</span>, 
and <span class="contact-name">Paul Wouters</span>.<a href="#appendix-C-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-D">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Landon Curt Noll</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:fnv-ietf8-mail@asthe.com" class="email">fnv-ietf8-mail@asthe.com</a>
</div>
<div class="url">
<span>URI:</span>
<a href="http://www.isthe.com/chongo" class="url">http://www.isthe.com/chongo</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Kiem-Phong Vo</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:phongvo@gmail.com" class="email">phongvo@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Donald E. Eastlake 3rd</span></div>
<div dir="auto" class="left"><span class="org">Independent</span></div>
<div dir="auto" class="left"><span class="street-address">2386 Panoramic Circle</span></div>
<div dir="auto" class="left">
<span class="locality">Apopka</span>, <span class="region">Florida</span> <span class="postal-code">32703</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="tel">
<span>Phone:</span>
<a href="tel:+1-508-333-2270" class="tel">+1-508-333-2270</a>
</div>
<div class="email">
<span>Email:</span>
<a href="mailto:d3e3e3@gmail.com" class="email">d3e3e3@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Tony Hansen</span></div>
<div dir="auto" class="left"><span class="org">AT&amp;T</span></div>
<div dir="auto" class="left"><span class="street-address">200 Laurel Avenue South</span></div>
<div dir="auto" class="left">
<span class="locality">Middletown</span>, <span class="region">New Jersey</span> <span class="postal-code">07748</span>
</div>
<div dir="auto" class="left"><span class="country-name">United States of America</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:tony@att.com" class="email">tony@att.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
